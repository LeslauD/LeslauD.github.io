[
{
	"uri": "http://example.org/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "刘顿 华中科技大学硕士研究生在读\n瞎搞算法，搞到自闭了，准备run开发~\n"
},
{
	"uri": "http://example.org/resume/",
	"title": "个人简历",
	"tags": [],
	"description": "",
	"content": "  刘 顿   23 岁 男 湖北武汉   （0）137-2039-5441   zdunliu@163.com    自我评价  学习能力强，有一定的项目经验，能够自学掌握深度学习的基本知识，并运用到项目实践中。性格沉稳，能够有条不紊地安排工作流程。具有一定的思考分析问题的能力，遇到技术瓶颈可以冷静思考，理清思路，找到解决问题的方法。通过项目实践和各个程序设计比赛积累了一定的代码能力。\n 教育背景 2021 年 9 月——2024 年 6 月 华中科技大学 计算机技术  实验室：医学图像信息研究中心\n 研究方向：医学图像处理\n 主修课程：数字图像处理技术及应用，生物医学图像处理，计算机视觉， 图像处理软件开发与设计实践\n2017 年 9 月——2021 年 6 月 武汉纺织大学 软件工程(大数据方向)  主修课程：数据科学导论,大数据可视化, 机器学习, 数据采集与网络爬虫,Python 数据分析与挖掘\n 学业表现：本科期间 GPA 为 3.88，智育成绩排名平均班级前 13%\n 在校奖励：多次获得三好学生及校级奖学金，蓝桥杯省赛三等奖(C++)，\n “泰迪杯”数据挖掘挑战赛省级一等奖， 微信小程序大赛华中赛区三等奖\n 获得证书：CET4,CET6\n2014 年 9 月——2017 年 6 月 武汉市蔡甸区汉阳一中  学业表现：学渣刷题机器~\n2011 年 9 月——2014 年 6 月 蔡甸区奓山中学  (一个个人觉得更高级的说法：汉阳县第十九中学)\n 学业表现：学渣做题家~\n2004 年 9 月——2011 年 6 月 蔡甸区奓山中心小学  学业表现：平平无奇~\n 项目经历 基于深度学习的产后妇女形体评估系统（2021.08-至今）  担当角色：主要成员\n 主要工作： 该系统首先通过 kinect 深度相机采集体表的深度图像，经过预处理后分割 出人体区域。然后通过深度学习的方式识别出人体体表主要关键点的位置，同时利用深度 图 像的空间映射关系计算出肩膀，脊椎，骨盆，下肢区域的指标数值，最后以图表的方式呈现 结果。（本项目是 2020 届师兄的毕业论文，前面还有两个 2021 届师兄师姐），本人目前的主要工作是对分割出人体的深度图像进行进一步处理，以优化显示效果，例如各种滤波，目 前正在尝试使用水平集方法检测人体边缘轮廓并进行平滑。\n 主要收获： 学习掌握了 OpenCV、QT、VTK 等用于图像及 UI 界面开发的框架，积累了 C++项目经验。\n“泰迪杯”数据挖掘挑战赛（2020，春）  担当角色：组长\n 主要工作：电力巡检智能缺陷检测，实现对绝缘子串珠的分割以及对自爆绝缘子的识别和定位，即目标检测。\n 主要收获：了解了图像分割，分类，目标检测的主要任务和区别，学习了用于目标检测 的 yolo 神经网络。\n2020 微信小程序应用开发赛（2020，春）  担当角色：核心成员\n 主要工作：实现一个基于面部表情识别的生活类微信小程序。完成了前端页面的设计， 以及神经网络的构建及部署。\n 主要收获：掌握了如何将一个神经网络部署到具体的应用，锻炼了前端的代码能力。对 一个软件的开发流程有所掌握，即从需求分析到最终的成品的过程。 熟悉了 JavaScript， Html，CSS。\n基于鼠脑数据集的细胞和血管分割（2019.09-2021.03）  担当角色：核心成员\n 主要工作：对鼠脑 MOST 图像采用深度学习及图像处理方法进行分割，得到目标区域 (胞体和血管)。实现了同时对细胞体和血管进多标签的图像分割，准确率均达到 98%以上。 基于此项目，有一篇 SCI 论文已发表。\n 主要收获：对进行一个完整的数据分析的流程有所掌握，从数据预处理到搭建神经网络以及数据后处理。积累了关于图像处理，计算机视觉，深度学习神经网络的相关知识。对 keras(TF),docker,opencv 等相关技术有所了解。\n鼠脑神经元人工重建(2018，夏)  担当角色：组长/志愿者\n 主要工作：协助武汉国家光电研究中心生物医学光子学功能实验室进行鼠脑神经元人工 重建的工作，在 MOST 图像上对神经元进行标注。个人完成 4 至 6 条完整神经元的标注， 作为小组长帮助队友进行实验，作为项目志愿者，帮老师检查其它小组的神经元标注，并进行纠错。\n 主要收获：了解了数据标注对于数据科学的重要性，作为小组长锻炼了团队协作能力， 作为项目志愿者锻炼了人际沟通能力\n"
},
{
	"uri": "http://example.org/photograph/",
	"title": "摄影",
	"tags": [],
	"description": "",
	"content": "摄影 "
},
{
	"uri": "http://example.org/machinelearning/",
	"title": "机器学习",
	"tags": [],
	"description": "",
	"content": "机器学习 "
},
{
	"uri": "http://example.org/deeplearning/",
	"title": "深度学习",
	"tags": [],
	"description": "",
	"content": "深度学习 "
},
{
	"uri": "http://example.org/algorithm/",
	"title": "算法",
	"tags": [],
	"description": "",
	"content": "算法 "
},
{
	"uri": "http://example.org/vehicle/",
	"title": "车车",
	"tags": [],
	"description": "",
	"content": "车车 "
},
{
	"uri": "http://example.org/piano/",
	"title": "钢琴",
	"tags": [],
	"description": "",
	"content": "钢琴 "
},
{
	"uri": "http://example.org/programs/",
	"title": "项目",
	"tags": [],
	"description": "",
	"content": "项目 "
},
{
	"uri": "http://example.org/cxx/clang/",
	"title": "C language",
	"tags": [],
	"description": "",
	"content": "常量与变量 变量 常量 常见关键字 注释 数据类型 数据类型的本质与作用 基本类型 构造类型 空类型void 指针类型 数据存储 整型存储 浮点型存储 大小端 分支、循环语句 分支语句 循环语句 操作符 算术操作符 移位操作符 位操作符 赋值操作符 单目操作符 关系操作符 逻辑操作符 条件操作符 逗号表达式 下标引用、函数调用和结构体成员 表达式求值 函数 数组 \n指针 \n动态内存管理 \n文件操作 \n代码编译 "
},
{
	"uri": "http://example.org/cxx/",
	"title": "CPP",
	"tags": [],
	"description": "",
	"content": "C++ "
},
{
	"uri": "http://example.org/cxx/cpp/",
	"title": "CPP",
	"tags": [],
	"description": "",
	"content": "C++基础 C语言 函数  函数的默认参数 在函数声明或定义的形参列表中，为形参提供默认值 函数重载  同一个作用域内，函数的形参不同，函数名相同，则这些函数构成重载函数(与返回值类型无关) 函数如何构成重载：编译器在编译时对函数进行了重命名   内联函数  定义在类内的函数会自动成为内联函数 内联函数只是对编译器的一种建议，编译器可以选择忽略这种建议 内联函数相比普通函数没有函数压栈的开销，提升了程序运行效率 内联是一种以空间换取时间的做法，省去了调用函数的开销，代码很长的函数不适合作为内联函数    引用  引用变量是所引用变量的别名，地址与原变量的地址相同 引用与指针  引用必须在定义时就要初始化 引用变量和指针变量的自增自减运算 引用和指针变量的大小   引用作为函数参数：参数传递时不会产生临时变量  类和对象 类的默认成员函数  构造函数  调用场景：类的对象在被创建时自动调用构造函数 构造函数一般完成构造对象以及初始化工作 如果没有显式定义，编译器会自动产生一个缺省的默认构造函数 无参的构造函数和全缺省值的构造函数都被认为是缺省构造函数，一个类中，缺省的构造函数只能有一个 构造函数没有返回值，可以重载，函数名与类名相同 构造函数的参数列表：  更高效(两次构造函数变成一次拷贝构造函数) const、引用、没有默认参数的构造函数的类对象必须在构造函数的初始化列表中进行初始化     析构函数  调用场景：类对象的生命周期结束会自动调用析构函数 析构函数主要完成的是内存的释放以及对象的销毁等工作 析构函数的函数名是在类名前面加上~ 如果没有显式的提供析构函数，编译器会自动生成一个默认的析构函数   拷贝构造函数  调用场景：用一个已经存在的对象创建一个新对象 拷贝构造函数其实是构造函数的重载 拷贝构造函数的参数必须是引用传参，其他传参方式会引起无穷递归 如果没有显式提供拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数，在默认的拷贝构造函数中采用了浅拷贝的方式   赋值运算符重载 取地址运算符重载 const修饰的取地址运算符重载  this指针  指向类的对象的地址 构造函数和静态成员函数中不存在this指针 this隐式地存在在类的成员函数中，但可以进行显式访问  静态成员  静态成员属于类，不属于对象 静态成员变量和函数需要在类外进行定义和初始化  友元  友元类  一个类被friend class在另一个类中，这另一个类可以访问这个类的对象的成员   友元函数  友元函数可以访问类的成员    const成员函数  this指针指向的内容不能被修改  模板 函数模板  template\u0026lt;模板参数\u0026gt; 实例化函数模板 通过函数实参推演模板实参，并绑定到模板参数上  非类型模板参数 类模板  使用了类模板后，用类模板创建一个对象时必须显式地提供类型 当类中的成员函数在类外定义时，必须加上template后接模板参数列表 返回值，类名作为形参 需要加上模板参数列表  分离编译  类的定义和类中函数的定义放在一个文件中  模板的特化  重新定义模板时在模板参数列表中显式地指定类型  异常 异常对象  编译器使用throw抛出去的表达式  异常产生 throw 异常处理 try与catch  一个异常如果没有被捕获，则会提前终止程序 栈展开的过程中对象被自动销毁(例如在构造函数中抛出异常) 如果析构函数中要抛出异常 try语句和catch语句应写在析构函数内部  编程技巧 浅拷贝/深拷贝/写时拷贝 类型萃取 泛型编程 继承和多态 继承  继承是面向对象的重要复用手段 三种继承关系  公有继承：public  基类的非私有成员在子类访问属性不变 is-a原则   私有继承：private  基类的非私有成员都变为子类的私有成员   保护继承：protected  基类的非私有成员都变为子类的protected成员     注：基类的私有成员在派生类中不能访问 赋值兼容规则  可以用一个子类对象给一个父类对象赋值 父类对象的指针或引用可以指向子类对象 上面两条反转过来不能实现，虽然可以进行强制类型转换，但这样非常容易出现访问错误的情况   派生类的6个默认构造函数 菱形继承  在孙子类的对象中存在两份父类的成员(二义性、数据冗余) 解决方法：虚拟继承 虚拟继承  专门用来解决菱形继承中存在的二义性和数据冗余的问题 使用虚拟继承会带来性能上的损耗 采用的偏移量的方式来解决二义性的问题     纯虚函数  在函数形参列表后写上“=0”叫做纯虚函数 包含纯虚函数的类叫做抽象类，抽象类不能实例化，只有在派生类中重新定义后才能实例化出对象   把析构函数写成虚函数 不会造成内存泄漏(编译器在这一块做了特殊处理)  多态  什么是多态  一个接口，多种方法   多态的实现条件  继承关系 只有在父类定义了虚函数，并且子类重写虚函数的情况下多态才能被实现 必须是父类的指针/引用指向子类或者父类的对象   多态的实现原因\u0026mdash;虚函数列表  虚函数列表是用一块连续的内存来存储虚函数的地址 虚函数表怎么解决虚函数的重写问题  父类中的虚函数如果在子类中被重新定义，则构成重写，虚函数表中的父类函数的弟子被子类函数所覆盖 子类重写父类的虚函数形参和函数名以及返回类型必须相同 上述规则对一条无效：斜变(函数返回值类型为类本身的指针或引用时函数重写仍然发生)：父类与子类必须对应 final关键字 定义在函数的形参列表后面，不允许派生类的子类的虚构函数进行重写 override关键字 会匹配子类与父类函数名相同的函数形参和类型是否一致，不一致则会报错   单继承 只会出现一张虚函数表，虚函数表先存放父类的虚函数，再存放子类的虚函数 多继承 会出现多个虚函数表，子类的虚函数会放在第一个虚函数表中   静态多态 函数重载 静态多态主要再编译期间发生，例如函数重载在编译期间对函数名进行了重命名  动态内存管理 new和delete  new开辟空间可以进行初始化 eg: new int(10)  new[]和delete[]  new int[10]()也可以进行初始化，但只能是上面这种形式，开辟的数组被初始化为0  相比于C语言的动态内存管理，C++的动态内存管理  new new[] delete delete[]是操作符，不是函数 new和new[]在开辟空间后还调用了类的构造函数 delete和delete[]先调用析构函数，再释放内存空间 new和new[]不需要进行强制类型转换  定位new表达式  定位new表达式是在已分配的内存空间中调用构造函数初始化一个对象 new(pA)type(init-list):其中pA是指向初始化这个类并且开辟了内存空间的指针  "
},
{
	"uri": "http://example.org/bigdata/hadoop/",
	"title": "Hadoop",
	"tags": [],
	"description": "",
	"content": "Hadoop系统简介  Hadoop 是一种分析和处理大数据的软件平台，是一个用 Java 语言实现的 Apache 的开源软件框架，在大量计算机组成的集群中实现了对海量数据的分布式计算。\n Hadoop 采用 MapReduce 分布式计算框架，根据 GFS 原理开发了 HDFS（分布式文件系统），并根据 BigTable 原理开发了 HBase 数据存储系统。\n Hadoop 和 Google 内部使用的分布式计算系统原理相同，其开源特性使其成为分布式计算系统的事实上的国际标准。\n Yahoo、Facebook、Amazon，以及国内的百度、阿里巴巴等众多互联网公司都以 Hadoop 为基础搭建了自己的分布式计算系统。\n Hadoop 是一个基础框架，允许用简单的编程模型在计算机集群上对大型数据集进行分布式处理。它的设计规模从单一服务器到数千台机器，每个服务器都能提供本地计算和存储功能，框架本身提供的是计算机集群高可用的服务，不依靠硬件来提供高可用性。用户可以在不了解分布式底层细节的情况下，轻松地在 Hadoop 上开发和运行处理海量数据的应用程序。低成本、高可靠、高扩展、高有效、高容错等特性让 hadoop 成为最流行的大数据分析系统。\nHadoop 生态圈 其中，HDFS是一个提供高可用的获取应用数据的分布式文件系统；MapReduce是一个并行处理大数据集的编程模型。\nHDFS MapReduce "
},
{
	"uri": "http://example.org/bigdata/spark/",
	"title": "Spark",
	"tags": [],
	"description": "",
	"content": "Spark环境搭建  在Linux上搭建spark环境，使用VMWare,安装Ubuntu22.04系统\n1、安装JDK 参考文献：https://blog.csdn.net/ZhangYing_Jie/article/details/124314495\nsudo表示切换用户权限，也可以先 su root切换到root用户\n在/usr/local/中创建java目录\nsudo mkdir /usr/local/java Java官网下载jdk8\n解压JDK到java目录\nsudo tar -zxvf jdk-18_linux-x64_bin.tar.gz -C /usr/local/java/ 配置环境变量\nvi /etc/profile 按下字母i进入insert模式\n也可以使用gedit编辑\ngedit /etc/profile 打开文件后在末尾加入\nJAVA_HOME=/usr/local/java/jdk PATH=$JAVA_HOME/bin:$PATH CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar export PATH JAVA_HOME CLASSPATH 使得修改生效：\nsource /etc/profile 也可以直接使用如下命令安装JDK\nsudo apt install openjdk-8-jre-headless 检查是否安装成功：\njava -version 2、安装Scala  安装scala  ​\t按照提示安装即可，但是官网下载会很慢，还有可能被墙\n​\t使用镜像站(https://distfiles.macports.org/scala3.1/)，下载压缩包解压,配置环境变量\n​\t或者直接使用命令\nsudo apt install scala ​\t检查是否安装成功\n3、安装Spark 下载压缩包（https://www.apache.org/dyn/closer.lua/spark/spark-3.2.1/spark-3.2.1-bin-hadoop3.2.tgz）\n解压到/opt/spark-hadoop\n配置环境变量\n# java\nJAVA_HOME=/usr/local/java/jdk PATH=$JAVA_HOME/bin:$PATH CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar export PATH JAVA_HOME CLASSPATH\n#scala\nexport SCALA_HOME=/opt/scala3-3.1.2 export PATH=${SCALA_HOME}/bin:$PATH\n#spark\nexport SPARK_HOME=/opt/spark-hadoop/\nexport PYTHONPATH=/opt/spark-hadoop/python\n启动spark\n4、测试Spark可用 将py4j目录移动到python目录下\n启动python,调用pyspark\n"
},
{
	"uri": "http://example.org/bigdata/",
	"title": "大数据",
	"tags": [],
	"description": "",
	"content": "大数据 "
},
{
	"uri": "http://example.org/programs/bodyassessment/",
	"title": "BodyAssessment",
	"tags": [],
	"description": "",
	"content": "基于深度学习的产后妇女形体评估系统\n图像预处理 滤波 采用双边滤波平滑人体内部\n水平集 1、Localizing Region-Based Active Contours 2022-03-12 —— 2022-04-09\n  代码流程：\n  初始化轮廓为一个包含人体的矩形，内部为+c，外部为-c。（c=2）\n  开始演化\n  计算狄拉克函数\n作用是表明轮廓曲线周围的区域\n从上到下依次是：边界，远离边界的区域，和边界附近的区域\n  计算曲率\n一阶导：, || = 先对一阶导数单位化，再求二阶导数\n曲率curvature = + 即  计算前景与背景均值\n  先计算Heaviside函数，标识水平集的内部和外部（内部为1，外部为0，边界为0~1）\n  计算前景均值\n  计算背景均值\n    计算惩罚项\n将phi与一个拉普拉斯算子做卷积运算，以突出phi的边缘\n  更新phi的每个点的值\n      实验：\n  参数\nc为水平集内部点的初值\n  结果\n    ​\t​\t​\t左图为最终的轮廓，右图为最终的水平集phi可以看到都没有平滑，调整迭代次数，时间步长，λ，μ，ν，都没有明显的效果（220326周报-全局调参）。\n​\t220402—统计时间（microseconds），尝试初始轮廓换成椭圆\n   方法 患者ID 矩形水平集20轮 椭圆水平集30轮 椭圆水平集 20轮     1 409061 632310 396968   2 410979 592415 359038   3 415397 575459 360009   4 414089 596375 356047   5 399128 566481 358014   6 391003 560502 363057   7 385457 585406 363056   8 403885 561497 355049   9 389965 547533 370980   10 385965 527591 355050   11 389469 508668 358071   12 396982 501630 363055   13 395966 496705 365023   14 395943 505646 361034   15 389438 502631 351089   16 400473 497695 349039   17 391429 516645 358040   18 381009 503682 361034   19 429991 506644 354081   均值 398717.3158 541342.8947 360933.3684    考虑到初始轮廓也可能会影响水平集方法的效果，所以尝试了用椭圆作为初始轮廓\n水平集方法按照初步调参后效果比较好的参数进行时间统计\n矩形：迭代20次，演化步长m_timestep为0.01，m_lambda=0.01，m_mu=1.0. m_nu=1.0\n椭圆：迭代30次，演化步长m_timestep为0.01，m_lambda=0.01，m_mu=1.0. m_nu=1.0\n都没有明显的平滑效果。\n2、Distance Regularized Level Set Evolution and Its Application to Image Segmentation DRLSE 2022-04-09 —— 2022-05-14\n  代码流程\n  深度图转换成灰度图\nlow和high分别为深度值的最小和最大值\n  去除srcImg中灰度大于100的部分，以去除相对人体较亮的背景\n  求edge indicator g\n先对srcImg进行高斯滤波得到gbImg\n对gbImg求梯度dx,dy,得到计算g\n​\t目标边界的g值通常比其他区域要小\n  初始化轮廓为人体内部的两个矩形\n  开始演化\n    实验\n 参数 结果    3、Fast Global Minimization of the Active Contour/Snake Model GMAC 2022-05-14 —— 2022-05-28\n4、尝试结合前面的三种模型 "
},
{
	"uri": "http://example.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]