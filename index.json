[
{
	"uri": "http://example.org/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "刘顿 华中科技大学硕士研究生在读\n瞎搞算法，搞到自闭了，准备run开发~\n"
},
{
	"uri": "http://example.org/programs/bodyassessment/",
	"title": "BodyAssessment",
	"tags": [],
	"description": "",
	"content": "基于深度学习的产后妇女身体姿态检测系统 图像处理 "
},
{
	"uri": "http://example.org/piano/summer/",
	"title": "summer",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/resume/",
	"title": "个人简历",
	"tags": [],
	"description": "",
	"content": "  刘 顿   23 岁 男 湖北武汉   （0）137-2039-5441   zdunliu@163.com    自我评价  学习能力强，有一定的项目经验，能够自学掌握深度学习的基本知识，并运用到项目实践中。性格沉稳，能够有条不紊地安排工作流程。具有一定的思考分析问题的能力，遇到技术瓶颈可以冷静思考，理清思路，找到解决问题的方法。通过项目实践和各个程序设计比赛积累了一定的代码能力。\n 教育背景 2021 年 9 月——2024 年 6 月 华中科技大学 计算机技术  实验室：医学图像信息研究中心\n 研究方向：医学图像处理\n 主修课程：数字图像处理技术及应用，生物医学图像处理，计算机视觉， 图像处理软件开发与设计实践\n2017 年 9 月——2021 年 6 月 武汉纺织大学 软件工程(大数据方向)  主修课程：数据科学导论,大数据可视化, 机器学习, 数据采集与网络爬虫,Python 数据分析与挖掘\n 学业表现：本科期间 GPA 为 3.88，智育成绩排名平均班级前 13%\n 在校奖励：多次获得三好学生及校级奖学金，蓝桥杯省赛三等奖(C++)，\n “泰迪杯”数据挖掘挑战赛省级一等奖， 微信小程序大赛华中赛区三等奖\n 获得证书：CET4,CET6\n2014 年 9 月——2017 年 6 月 武汉市蔡甸区汉阳一中  学业表现：学渣刷题机器~\n2011 年 9 月——2014 年 6 月 蔡甸区奓山中学  (一个个人觉得更高级的说法：汉阳县第十九中学)\n 学业表现：学渣做题家~\n2004 年 9 月——2011 年 6 月 蔡甸区奓山中心小学  学业表现：平平无奇~\n 项目经历 基于深度学习的产后妇女形体评估系统（2021.08-至今）  担当角色：主要成员\n 主要工作： 该系统首先通过 kinect 深度相机采集体表的深度图像，经过预处理后分割 出人体区域。然后通过深度学习的方式识别出人体体表主要关键点的位置，同时利用深度 图 像的空间映射关系计算出肩膀，脊椎，骨盆，下肢区域的指标数值，最后以图表的方式呈现 结果。（本项目是 2020 届师兄的毕业论文，前面还有两个 2021 届师兄师姐），本人目前的主要工作是对分割出人体的深度图像进行进一步处理，以优化显示效果，例如各种滤波，目 前正在尝试使用水平集方法检测人体边缘轮廓并进行平滑。\n 主要收获： 学习掌握了 OpenCV、QT、VTK 等用于图像及 UI 界面开发的框架，积累了 C++项目经验。\n“泰迪杯”数据挖掘挑战赛（2020，春）  担当角色：组长\n 主要工作：电力巡检智能缺陷检测，实现对绝缘子串珠的分割以及对自爆绝缘子的识别和定位，即目标检测。\n 主要收获：了解了图像分割，分类，目标检测的主要任务和区别，学习了用于目标检测 的 yolo 神经网络。\n2020 微信小程序应用开发赛（2020，春）  担当角色：核心成员\n 主要工作：实现一个基于面部表情识别的生活类微信小程序。完成了前端页面的设计， 以及神经网络的构建及部署。\n 主要收获：掌握了如何将一个神经网络部署到具体的应用，锻炼了前端的代码能力。对 一个软件的开发流程有所掌握，即从需求分析到最终的成品的过程。 熟悉了 JavaScript， Html，CSS。\n基于鼠脑数据集的细胞和血管分割（2019.09-2021.03）  担当角色：核心成员\n 主要工作：对鼠脑 MOST 图像采用深度学习及图像处理方法进行分割，得到目标区域 (胞体和血管)。实现了同时对细胞体和血管进多标签的图像分割，准确率均达到 98%以上。 基于此项目，有一篇 SCI 论文已发表。\n 主要收获：对进行一个完整的数据分析的流程有所掌握，从数据预处理到搭建神经网络以及数据后处理。积累了关于图像处理，计算机视觉，深度学习神经网络的相关知识。对 keras(TF),docker,opencv 等相关技术有所了解。\n鼠脑神经元人工重建(2018，夏)  担当角色：组长/志愿者\n 主要工作：协助武汉国家光电研究中心生物医学光子学功能实验室进行鼠脑神经元人工 重建的工作，在 MOST 图像上对神经元进行标注。个人完成 4 至 6 条完整神经元的标注， 作为小组长帮助队友进行实验，作为项目志愿者，帮老师检查其它小组的神经元标注，并进行纠错。\n 主要收获：了解了数据标注对于数据科学的重要性，作为小组长锻炼了团队协作能力， 作为项目志愿者锻炼了人际沟通能力\n"
},
{
	"uri": "http://example.org/piano/cannon/",
	"title": "卡农",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/piano/basic/",
	"title": "基本乐理",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/piano/sunrise/",
	"title": "太阳照常升起",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/piano/littlestar/",
	"title": "小星星变奏曲",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/photograph/",
	"title": "摄影",
	"tags": [],
	"description": "",
	"content": "摄影 "
},
{
	"uri": "http://example.org/algorithm/",
	"title": "数据结构与算法",
	"tags": [],
	"description": "",
	"content": "PAT LeetCode NewCoder 剑指Offer "
},
{
	"uri": "http://example.org/machinelearning/",
	"title": "机器学习",
	"tags": [],
	"description": "",
	"content": "推荐系统 "
},
{
	"uri": "http://example.org/deeplearning/",
	"title": "深度学习",
	"tags": [],
	"description": "",
	"content": "深度学习 "
},
{
	"uri": "http://example.org/vehicle/",
	"title": "车车",
	"tags": [],
	"description": "",
	"content": "桑塔纳 "
},
{
	"uri": "http://example.org/piano/",
	"title": "钢琴",
	"tags": [],
	"description": "",
	"content": "基本乐理 小星星变奏曲 卡农 summer 太阳照常升起 "
},
{
	"uri": "http://example.org/programs/",
	"title": "项目",
	"tags": [],
	"description": "",
	"content": "BodyAssessment JoyYourMind MillenniumTemple "
},
{
	"uri": "http://example.org/cxx/clang/",
	"title": "C language",
	"tags": [],
	"description": "",
	"content": "C程序结构 预处理指令、函数、变量、语句\u0026amp;表达式、注释\n编译和执行 gcc xx.c 编译\n编译生成xx.out文件\nxx.out 执行\n编译和执行多个C源文件\ngcc aa.c bb.c -o main.out\nmain.out\n常量与变量 变量  变量分类  局部变量 全局变量(默认初始化为0)   定义与赋值  定义：int a = 0; \u0026hellip;\u0026hellip; 赋值：a = 1;   变量的作用域与生命周期  作用域  局部变量：变量所在局部范围 全局变量：整个工程   生命周期  局部变量：进行作用域开始，出作用域结束 全局变量：整个程序的生命周期     左值和右值  **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。    常量   字面常量\n 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。    const修饰的常变量\n 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。    枚举常量\n  字符串常量(\u0026ldquo;hello world\u0026rdquo;)\n  定义常量\n  使用 #define 预处理器\n eg. #define PI 3.1415926    使用 const 关键字\nconst 声明常量要在一个语句内完成\nconst int var; × const int bar; var = 5;\t× const int var = 5;\t√     常见关键字    关键字 说明     auto 声明自动变量   break 跳出当前循环   case 开关语句分支   char 声明字符型变量或函数返回值类型   const 定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变   continue 结束当前循环，开始下一轮循环   default 开关语句中的\u0026quot;其它\u0026quot;分支   do 循环语句的循环体   double 声明双精度浮点型变量或函数返回值类型   else 条件语句否定分支（与 if 连用）   enum 声明枚举类型   extern 声明变量或函数是在其它文件或本文件的其他位置定义，只是声明，不定义   float 声明浮点型变量或函数返回值类型   for 一种循环语句   goto 无条件跳转语句   if 条件语句   int 声明整型变量或函数   long 声明长整型变量或函数返回值类型   register 声明寄存器变量   return 子程序返回语句（可以带参数，也可不带参数）   short 声明短整型变量或函数   signed 声明有符号类型变量或函数   sizeof 计算数据类型或变量长度（即所占字节数）   static 声明静态变量   struct 声明结构体类型   switch 用于开关语句   typedef 用以给数据类型取别名   unsigned 声明无符号类型变量或函数   union 声明共用体类型   void 声明函数无返回值或无参数，声明无类型指针   volatile 说明变量在程序执行中可被隐含地改变   while 循环语句的循环条件     auto break case char const continue default do\u0026hellip;（32个） typedef 类型重命名 static  修饰变量  修饰局部变量：静态局部变量出作用域依然存在，到程序结束生命周期才结束 修饰全局变量：使该全局变量只能在本源文件内使用，不能在其他源文件内使用   修饰函数  被修饰的函数只能在本源文件内使用，不能在其他源文件内使用      注释  C语言风格：/* XXXXXXX */ C++风格：// XXXXXXX  数据类型 数据类型的本质与作用  本质：是固定内存大小的别名 作用：编译预算对象(变量)分配的内存空间的大小  基本类型   数值类型\n  整型：short、int、long、long long\n  浮点型：单精度float、双精度double\nfloat:double:    字符类型 char\n  标准整数类型的存储大小和值的范围：\n   类型 存储大小 值范围     char 1 字节 -128 到 127 或 0 到 255   unsigned char 1 字节 0 到 255   signed char 1 字节 -128 到 127   int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647   unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295   short 2 字节 -32,768 到 32,767   unsigned short 2 字节 0 到 65,535   long 4 字节 -2,147,483,648 到 2,147,483,647   unsigned long 4 字节 0 到 4,294,967,295    各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。\n以下列出了32位系统与64位系统的存储大小的差别（windows 相同）：\nsizeof(type) 得到对象或类型的存储字节大小\n下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：\n   类型 存储大小 值范围 精度     float 4 字节 1.2E-38 到 3.4E+38 6 位有效位   double 8 字节 2.3E-308 到 1.7E+308 15 位有效位   long double 16 字节 3.4E-4932 到 1.1E+4932 19 位有效位    构造类型   数组\n  共用体（联合体） union\n  特征：所有成员公用一块空间（共用）\n  联合大小计算：至少是最大成员的大小，最大成员不是最大对齐数整数倍时，对齐\n  union变量初始化时，只能对第一个成员赋值\n  union变量在一个时刻只能一个成员发挥作用，赋值时，成员之间会互相覆盖，最后一次被赋值的成员起作用。\n    枚举类型 enum\n​\t枚举语法定义格式为：\nenum　枚举名　{枚举元素1[=整型常数],枚举元素2[=整型常数],……}; 枚举元素是一个整型，枚举型可以隐式的转换为int型，int型不能隐式的转换为枚举型。\n  成员默认从0开始依次递增，也可以定义时赋初值（没有赋初值的元素按前面赋过初值的元素依次递增）\nenum course {math,chinese,english=1,physics,chemistry} 其中各个元素的值为：0，1，1，2，3\n  优点\n 增加代码可读性可维护性 和#define定义的标识符比较，枚举有类型，更加严谨 防止命名污染（封装） 便于调试 使用方便，一次可以定义多个常量      结构体struct\n  结构体声明(声明常配合typedef使用)\n  结构体定义与初始化\n  结构的引用\n  成员访问\n 结构体变量使用（.）stu.age 结构体指针使用（-\u0026gt;）p-\u0026gt;age    结构体内存对齐规则\n 数据成员的对齐规则（以最大的类型字节为单位） 结构体作为成员的对齐规则 收尾工作结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐    结构体大小和字节对齐 现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐. 为什么需要字节对齐？各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。 三个个概念：\n自身对齐值：数据类型本身的对齐值，结构体或类的的自身对齐值是其成员中最大的那个值，例如char类型的自身对齐值是1，short类型是2； 指定对齐值：编译器或程序员指定的对齐值，32位单片机的指定对齐值默认是4； 有效对齐值：自身对齐值和指定对齐值中较小的那个。 字节对齐的三个准则 结构体变量的首地址能够被其有效对齐值的大小所整除 结构体的总大小为结构体有效对齐值的整数倍。 结构体每个成员相对于结构体首地址的偏移量都是有效对齐值的整数倍。 可以通过#pragma pack(n)来设定变量以n字节对齐方式 作者：程序员-王坚 https://www.bilibili.com/read/cv14206037 出处：bilibili\n  为什么存在内存对齐\n 平台原因（移植原因） 性能原因    位段\n  成员必须是int、unsigned int、signed int\n  成员名后边一个冒号和一个数字 Int _a:2\n      空类型void  函数参数为空时：int fun(void) 函数没有返回值：void fun(void) 不能定义void型普通变量： void a //error 定义指针：void *p  指针类型 数据存储 整型存储  原码：直接将十进制按照正负数的形式翻译成二进制 反码：将原码的符号位不变，其他位依次按位取反 补码：反码+1得到补码 整型提升与整型截断问题 正数的原码、反码、补码相同 对于整型数据，数据存放在内存中其实存放的是补码  浮点型存储  (-1)^S*M*2^E (-1)^S表示符号位，当S=0时，V为正数，当S为1时，V为负数 M表示有效数字，大于等于1，小于2 2^E表示指数位  大小端  大端模式：数据的低位保存在内存的高地址中，数据的高位，保存在内存的低地址中 小端模式：数据的低位保存在内存的低地址中，数据的高位保存在内存的高地址中  分支、循环语句 分支语句  if、switch    语句 描述     if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。   if\u0026hellip;else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。   嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。   switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。   嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。      循环语句  while、for、do while、goto、break、continue    循环类型 描述     while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。   for 循环 多次执行一个语句序列，简化管理循环变量的代码。   do\u0026hellip;while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。   嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。         控制语句 描述     break 语句 终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。   continue 语句 告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。   goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。    操作符 算术操作符 + - * / %\n/ 是整除，%是取模(整除后的余数)\n移位操作符 \u0026laquo; \u0026raquo;\n   \u0026laquo; 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。     \u0026raquo; 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。    位操作符 \u0026amp; | ^ ~\n~是按位取反\n   p q p \u0026amp; q 与 p | q 或 p ^ q 异或     0 0 0 0 0   0 1 0 1 1   1 1 1 1 0   1 0 0 1 1    赋值操作符 = += -= *= /= %= \u0026raquo;= \u0026laquo;= \u0026amp;= |= ^=\n单目操作符 ! - + \u0026amp; sizeof ~ \u0026ndash; ++ *(解引用) (类型)类型强转\n关系操作符 \u0026gt; \u0026gt;= \u0026lt; \u0026lt;= != ==\n逻辑操作符 \u0026amp;\u0026amp; 第一项为false的话，就不用算第二项了\n|| 第一项为true的话，第二项就不用算了\n条件操作符 exp1?exp2:exp3\n逗号表达式 exp1,exp2,exp3,\u0026hellip;..,expN\n下标引用、函数调用和结构体成员   []下标引用操作符\n  ()函数调用操作符\n  访问结构体成员\n . 结构体.成员名 -\u0026gt; 结构体指针-\u0026gt;成员名    表达式求值  隐式类型转换 算数转换 复杂表达式求值影响因素  操作符优先级 操作符结合性 是否控制求值顺序    下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。\n   类别 运算符 结合性     后缀 () [] -\u0026gt; . ++ - - 从左到右   一元 + - ! ~ ++ - - (type)* \u0026amp; sizeof 从右到左   乘除 * / % 从左到右   加减 + - 从左到右   移位 \u0026laquo; \u0026raquo; 从左到右   关系 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 从左到右   相等 == != 从左到右   位与 AND \u0026amp; 从左到右   位异或 XOR ^ 从左到右   位或 OR | 从左到右   逻辑与 AND \u0026amp;\u0026amp; 从左到右   逻辑或 OR || 从左到右   条件 ?: 从右到左   赋值 = += -= *= /= %=\u0026raquo;= \u0026laquo;= \u0026amp;= ^= |= 从右到左   逗号 , 从左到右    函数 库函数  IO函数 字符串操作函数 字符操作函数 内存操作函数 时间/日期函数 数学函数 其他库函数  自定义函数 有函数名、返回值类型和函数参数，需要程序员自己设计\n函数的声明和定义   函数声明\n  告诉编译器函数名、参数、返回类型\n  先声明后使用\n  一般放在头文件中\nreturn_type function_name( parameter list );     函数定义\n 函数的具体实现，交待函数的功能实现    函数参数   实际参数（实参）\n 真实传递给函数的参数（常量、变量、表达式、函数）    形式参数（形参）\n 函数名括号后中的变量，只在函数调用过程中实例化(分配内存)，调用完后销毁    函数调用  传值调用：该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 传地址调用(引用调用)：通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。  函数的嵌套调用和链式访问  嵌套调用：函数中调用函数 链式访问：把一个函数的返回值作为另一个函数的参数  回调函数 通过函数指针调用的函数\n函数递归  概念：  程序调用自身；主要思考方式：大事化小   两个必要条件  存在限制条件，满足条件时递归不再继续 每次递归调用之后越来越接近限制条件    数组 一维数组  一维数组的创建与初始化：type_ arr_name[const_n] (eg: int arr[10]\u0026hellip;) 一维数组使用  使用下标访问，从0开始 计算数组成员个数 sizeof(arr)/sizeof(arr[1])   一维数组存储：在内存中连续存储  二维数组  二维数组创建 int arr[3][4]  \u0026amp;a：代表整个数组的首地址 a：代表第0行的首地址 a+i：相当于\u0026amp;a[i]，代表第i行首地址 *(a+i)：相当于a[i]，代表第i行首元素地址 *(a+i)+j：相当于\u0026amp;a[i][j]，代表第i行第i列元素地址 *(*(a+i)+j)：相当于a[i][j]，代表第i行第j列元素的值   二维数组初始化 二维数组的存储：在内存中连续存储，第一行存完，紧接着存储第二行\u0026hellip;\u0026hellip;.  指针数组 存放指针变量的数组 int* arr[10]，数组中每一个成员都是指针变量\n数组作为函数参数 数组作为函数参数时退化为指针\n指针 指针变量 存放地址的变量（指针变量中的值会被当做内存单元地址处理）\n指针类型 在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。\nNULL 指针是一个定义在标准库中的值为零的常量。\n 自定义类型  int*、char*、short*、long*、float*、double*、   字符指针  char* str=\u0026ldquo;hello\u0026rdquo;;   数组指针  int (*p)[10]，p的类型为int(*)[10]   函数指针  指向函数的指针 函数指针 fun void(*fun)() 类型void(*)() 函数指针数组 int (*parr[10])() 转移表   指针类型总结  指针类型决定了指针向前向后走一步走多大（距离） 指针类型决定了对指针解引用的时候有多大权限（能操作几个字节）    指针运算  指针+-整数 指针-指针 指针的关系运算  动态内存管理 malloc  void* malloc(size_t size) 开辟成功，返回一个指向开辟好空间的指针 开辟失败，返回一个NULL指针 返回值类型是void* 如果size为0，malloc行为取决于编译器  calloc  void* calloc(size_t num, size_t size) 功能是为num个大小为size的元素开辟一块空间，并初始化为0 与malloc的区别为会在返回地址前把申请的空间初始化为0  realloc  void* realloc(void* ptr, size_t size) 让动态内存管理更加灵活 ptr是要调整的内存地址 size调整之后的新大小 返回值为调整之后的内存起始位置 realloc在调整原内存大小的基础上，还会将原来内存中的数据移动到新空间  free  void free(void* ptr) 如果ptr指向的空间不是动态开辟的，那free函数行为未定义 如果ptr是NULL指针，则函数不动作  文件操作 文件分类  普通文件 设备文件 文本文件 二进制文件  文件打开与关闭  fopen fclose  文件读写  按照字符读写  fputc fgetc   按照行读写  fgets fputs   按照块读写  fread fwrite   按照格式化读写  fprintf fscanf   随机读写  fseek  SEEK_SET 文件开头 SEEK_CUR 文件当前位置 SEEK_END 文件结尾      代码编译 预处理  gcc -E xx.c -o xx.i  展开头文件 去注释 宏替换 条件编译    编译  gcc -S xx.i -o xx.s  将C文件转换为二进制文件    汇编  gcc -c xx.s -o xx.o  将汇编文件转换为而进行文件    连接  gcc xx.o -o xx  将所有.o文件和依赖库文件连接在一起，生成可执行文件    C命令行参数 执行程序时，可以从命令行传值给 C 程序。这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。\n命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。\nargv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针，*argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，argc 将被设置为 2。\n"
},
{
	"uri": "http://example.org/cxx/",
	"title": "CPP",
	"tags": [],
	"description": "",
	"content": "C C++ "
},
{
	"uri": "http://example.org/cxx/cpp/",
	"title": "CPP",
	"tags": [],
	"description": "",
	"content": "C++基础 C语言 ^-^\n函数  函数的默认参数 在函数声明或定义的形参列表中，为形参提供默认值 函数重载  同一个作用域内，函数的形参不同，函数名相同，则这些函数构成重载函数(与返回值类型无关) 函数如何构成重载：编译器在编译时对函数进行了重命名   内联函数  定义在类内的函数会自动成为内联函数 内联函数只是对编译器的一种建议，编译器可以选择忽略这种建议 内联函数相比普通函数没有函数压栈的开销，提升了程序运行效率 内联是一种以空间换取时间的做法，省去了调用函数的开销，代码很长的函数不适合作为内联函数    引用  引用变量是所引用变量的别名，地址与原变量的地址相同 引用与指针  引用必须在定义时就要初始化 引用变量和指针变量的自增自减运算 引用和指针变量的大小   引用作为函数参数：参数传递时不会产生临时变量  类和对象 类的默认成员函数  构造函数  调用场景：类的对象在被创建时自动调用构造函数 构造函数一般完成构造对象以及初始化工作 如果没有显式定义，编译器会自动产生一个缺省的默认构造函数 无参的构造函数和全缺省值的构造函数都被认为是缺省构造函数，一个类中，缺省的构造函数只能有一个 构造函数没有返回值，可以重载，函数名与类名相同 构造函数的参数列表：  更高效(两次构造函数变成一次拷贝构造函数) const、引用、没有默认参数的构造函数的类对象必须在构造函数的初始化列表中进行初始化     析构函数  调用场景：类对象的生命周期结束会自动调用析构函数 析构函数主要完成的是内存的释放以及对象的销毁等工作 析构函数的函数名是在类名前面加上~ 如果没有显式的提供析构函数，编译器会自动生成一个默认的析构函数   拷贝构造函数  调用场景：用一个已经存在的对象创建一个新对象 拷贝构造函数其实是构造函数的重载 拷贝构造函数的参数必须是引用传参，其他传参方式会引起无穷递归 如果没有显式提供拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数，在默认的拷贝构造函数中采用了浅拷贝的方式   赋值运算符重载 取地址运算符重载 const修饰的取地址运算符重载  this指针  指向类的对象的地址 构造函数和静态成员函数中不存在this指针 this隐式地存在在类的成员函数中，但可以进行显式访问  静态成员  静态成员属于类，不属于对象 静态成员变量和函数需要在类外进行定义和初始化  友元  友元类  一个类被friend class在另一个类中，这另一个类可以访问这个类的对象的成员   友元函数  友元函数可以访问类的成员    const成员函数  this指针指向的内容不能被修改  模板 函数模板  template\u0026lt;模板参数\u0026gt; 实例化函数模板 通过函数实参推演模板实参，并绑定到模板参数上  非类型模板参数 类模板  使用了类模板后，用类模板创建一个对象时必须显式地提供类型 当类中的成员函数在类外定义时，必须加上template后接模板参数列表 返回值，类名作为形参 需要加上模板参数列表  分离编译  类的定义和类中函数的定义放在一个文件中  模板的特化  重新定义模板时在模板参数列表中显式地指定类型  异常 异常对象  编译器使用throw抛出去的表达式  异常产生 throw 异常处理 try与catch  一个异常如果没有被捕获，则会提前终止程序 栈展开的过程中对象被自动销毁(例如在构造函数中抛出异常) 如果析构函数中要抛出异常 try语句和catch语句应写在析构函数内部  编程技巧 浅拷贝/深拷贝/写时拷贝 类型萃取 泛型编程 继承和多态 继承  继承是面向对象的重要复用手段 三种继承关系  公有继承：public  基类的非私有成员在子类访问属性不变 is-a原则   私有继承：private  基类的非私有成员都变为子类的私有成员   保护继承：protected  基类的非私有成员都变为子类的protected成员     注：基类的私有成员在派生类中不能访问 赋值兼容规则  可以用一个子类对象给一个父类对象赋值 父类对象的指针或引用可以指向子类对象 上面两条反转过来不能实现，虽然可以进行强制类型转换，但这样非常容易出现访问错误的情况   派生类的6个默认构造函数 菱形继承  在孙子类的对象中存在两份父类的成员(二义性、数据冗余) 解决方法：虚拟继承 虚拟继承  专门用来解决菱形继承中存在的二义性和数据冗余的问题 使用虚拟继承会带来性能上的损耗 采用的偏移量的方式来解决二义性的问题     纯虚函数  在函数形参列表后写上“=0”叫做纯虚函数 包含纯虚函数的类叫做抽象类，抽象类不能实例化，只有在派生类中重新定义后才能实例化出对象   把析构函数写成虚函数 不会造成内存泄漏(编译器在这一块做了特殊处理)  多态  什么是多态  一个接口，多种方法   多态的实现条件  继承关系 只有在父类定义了虚函数，并且子类重写虚函数的情况下多态才能被实现 必须是父类的指针/引用指向子类或者父类的对象   多态的实现原因\u0026mdash;虚函数列表  虚函数列表是用一块连续的内存来存储虚函数的地址 虚函数表怎么解决虚函数的重写问题  父类中的虚函数如果在子类中被重新定义，则构成重写，虚函数表中的父类函数的弟子被子类函数所覆盖 子类重写父类的虚函数形参和函数名以及返回类型必须相同 上述规则对一条无效：斜变(函数返回值类型为类本身的指针或引用时函数重写仍然发生)：父类与子类必须对应 final关键字 定义在函数的形参列表后面，不允许派生类的子类的虚构函数进行重写 override关键字 会匹配子类与父类函数名相同的函数形参和类型是否一致，不一致则会报错   单继承 只会出现一张虚函数表，虚函数表先存放父类的虚函数，再存放子类的虚函数 多继承 会出现多个虚函数表，子类的虚函数会放在第一个虚函数表中   静态多态 函数重载 静态多态主要再编译期间发生，例如函数重载在编译期间对函数名进行了重命名  动态内存管理 new和delete  new开辟空间可以进行初始化 eg: new int(10)  new[]和delete[]  new int[10]()也可以进行初始化，但只能是上面这种形式，开辟的数组被初始化为0  相比于C语言的动态内存管理，C++的动态内存管理  new new[] delete delete[]是操作符，不是函数 new和new[]在开辟空间后还调用了类的构造函数 delete和delete[]先调用析构函数，再释放内存空间 new和new[]不需要进行强制类型转换  定位new表达式  定位new表达式是在已分配的内存空间中调用构造函数初始化一个对象 new(pA)type(init-list):其中pA是指向初始化这个类并且开辟了内存空间的指针  STL vector   创建：\n  创建空的vector\nstd::vector\u0026lt;typename\u0026gt; values; reserve函数增加容量\nvalues.reserve(20)   创建的同时指定初始值\nstd::vector\u0026lt;int\u0026gt; primes {2, 3, 5, 7, 11, 13, 17, 19};   创建时指定元素个数\nstd::vector\u0026lt;double\u0026gt; values(20); 默认初值为0，也可以指定初值\nstd::vector\u0026lt;double\u0026gt; values(20,1.0); //圆括号中的参数也可以是变量 int num=20; double value =1.0; std::vector\u0026lt;double\u0026gt; values(num, value);   通过存储元素类型相同的其他容器创建新的容器\nstd::vector\u0026lt;char\u0026gt;value1(5, \u0026#39;c\u0026#39;); std::vector\u0026lt;char\u0026gt;value2(value1); //也可以指定取其他容器中的哪些元素 int array[]={1,2,3}; std::vector\u0026lt;int\u0026gt;values(array, array+2);//values 将保存{1,2} std::vector\u0026lt;int\u0026gt;value1{1,2,3,4,5}; std::vector\u0026lt;int\u0026gt;value2(std::begin(value1),std::begin(value1)+3);//value2保存{1,2,3}     vector的成员函数\n   函数成员 函数功能     begin() 返回指向容器中第一个元素的迭代器。   end() 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。   rbegin() 返回指向最后一个元素的迭代器。   rend() 返回指向第一个元素所在位置前一个位置的迭代器。   cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。   cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。   crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。   crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。   size() 返回实际元素个数。   max_size() 返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。   resize() 改变实际元素的个数。   capacity() 返回当前容量。   empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。   reserve() 增加容器的容量。   shrink _to_fit() 将内存减少到等于当前元素实际所使用的大小。   operator[ ] 重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。   at() 使用经过边界检查的索引访问元素。   front() 返回第一个元素的引用。   back() 返回最后一个元素的引用。   data() 返回指向容器中第一个元素的指针。   assign() 用新元素替换原有内容。   push_back() 在序列的尾部添加一个元素。   pop_back() 移出序列尾部的元素。   insert() 在指定的位置插入一个或多个元素。   erase() 移出一个元素或一段元素。   clear() 移出所有的元素，容器大小变为 0。   swap() 交换两个容器的所有元素。   emplace() 在指定的位置直接生成一个元素。   emplace_back() 在序列尾部生成一个元素。      pair 专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素\u0026lt;first, second\u0026gt;\npair 类模板定义在头文件中\n 构造函数  #1) 默认构造函数，即创建空的 pair 对象 pair(); #2) 直接使用 2 个元素初始化成 pair 对象 pair (const first_type\u0026amp; a, const second_type\u0026amp; b); #3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象 template\u0026lt;class U, class V\u0026gt; pair (const pair\u0026lt;U,V\u0026gt;\u0026amp; pr); #4) 移动构造函数 template\u0026lt;class U, class V\u0026gt; pair (pair\u0026lt;U,V\u0026gt;\u0026amp;\u0026amp; pr); #5) 使用右值引用参数，创建 pair 对象 template\u0026lt;class U, class V\u0026gt; pair (U\u0026amp;\u0026amp; a, V\u0026amp;\u0026amp; b); \u0026lt;utility\u0026gt;头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 \u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;=、==、!= 这 6 的运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小。\nmap map容器存储的都是pair对象\n 创建   通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器，比如：  std::map\u0026lt;std::string, int\u0026gt; myMap;  创建的同时初始化\nstd::map\u0026lt;std::string, int\u0026gt; myMap{ {\u0026#34;C语言教程\u0026#34;,10},{\u0026#34;STL教程\u0026#34;,20} }; // 或者创建pair对象 std::map\u0026lt;std::string, int\u0026gt; myMap{std::make_pair(\u0026#34;C语言教程\u0026#34;,10),std::make_pair(\u0026#34;STL教程\u0026#34;,20)};   拷贝构造\nstd::map\u0026lt;std::string, int\u0026gt; newMap(myMap);   map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器\nstd::map\u0026lt;std::string, int\u0026gt; myMap{ {\u0026#34;C语言教程\u0026#34;,10},{\u0026#34;STL教程\u0026#34;,20} }; std::map\u0026lt;std::string, int\u0026gt; newMap(++myMap.begin(), myMap.end());   手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。\nstd::map\u0026lt;std::string, int\u0026gt;myMap{ {\u0026#34;C语言教程\u0026#34;,10},{\u0026#34;STL教程\u0026#34;,20} }; std::map\u0026lt;std::string, int, std::less\u0026lt;std::string\u0026gt; \u0026gt;myMap{ {\u0026#34;C语言教程\u0026#34;,10},{\u0026#34;STL教程\u0026#34;,20} }; \u0026lt;\u0026ldquo;C语言教程\u0026rdquo;, 10\u0026gt; \u0026lt;\u0026ldquo;STL教程\u0026rdquo;, 20\u0026gt;\nstd::map\u0026lt;std::string, int, std::greater\u0026lt;std::string\u0026gt; \u0026gt;myMap{ {\u0026#34;C语言教程\u0026#34;,10},{\u0026#34;STL教程\u0026#34;,20} }; \u0026lt;\u0026ldquo;STL教程\u0026rdquo;, 20\u0026gt; \u0026lt;\u0026ldquo;C语言教程\u0026rdquo;, 10\u0026gt;\n   map容器包含的成员方法     成员方法 功能     begin() 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。   end() 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。   rbegin() 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。   rend() 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。   cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。   cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。   crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。   crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。   find(key) 在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。   lower_bound(key) 返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。   upper_bound(key) 返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。   equal_range(key) 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。   empty() 若容器为空，则返回 true；否则 false。   size() 返回当前 map 容器中存有键值对的个数。   max_size() 返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。   operator[] map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。   at(key) 找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。   insert() 向 map 容器中插入键值对。   erase() 删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。   swap() 交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。   clear() 清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。   emplace() 在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。   emplace_hint() 在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。   count(key) 在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。    set set 容器存储的各个元素的值必须各不相同,采用默认的 std::less\u0026lt;T\u0026gt; 规则排序\n  创建\n  调用默认构造函数，创建空的 set 容器\nstd::set\u0026lt;std::string\u0026gt; myset;   创建的同时初始化\nstd::set\u0026lt;std::string\u0026gt; myset{\u0026#34;http://c.biancheng.net/java/\u0026#34;,  \u0026#34;http://c.biancheng.net/stl/\u0026#34;,  \u0026#34;http://c.biancheng.net/python/\u0026#34;};   拷贝构造函数\nstd::set\u0026lt;std::string\u0026gt; copyset(myset); //等同于 std::set\u0026lt;std::string\u0026gt; copyset = myset   取已有 set 容器中的部分元素，来初始化新 set 容器\nstd::set\u0026lt;std::string\u0026gt; myset{ \u0026#34;http://c.biancheng.net/java/\u0026#34;,  \u0026#34;http://c.biancheng.net/stl/\u0026#34;,  \u0026#34;http://c.biancheng.net/python/\u0026#34; }; std::set\u0026lt;std::string\u0026gt; copyset(++myset.begin(), myset.end());   手动修改 set 容器中的排序规则\nstd::set\u0026lt;std::string,std::greater\u0026lt;string\u0026gt; \u0026gt; myset{ \u0026#34;http://c.biancheng.net/java/\u0026#34;, \u0026#34;http://c.biancheng.net/stl/\u0026#34;, \u0026#34;http://c.biancheng.net/python/\u0026#34;};     成员方法\n   成员方法 功能     begin() 返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。   end() 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。   rbegin() 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。   rend() 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。   cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。   cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。   crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。   crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。   find(val) 在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。   lower_bound(val) 返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。   upper_bound(val) 返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。   equal_range(val) 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。   empty() 若容器为空，则返回 true；否则 false。   size() 返回当前 set 容器中存有元素的个数。   max_size() 返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。   insert() 向 set 容器中插入元素。   erase() 删除 set 容器中存储的元素。   swap() 交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。   clear() 清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。   emplace() 在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。   emplace_hint() 在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。   count(val) 在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。      unorder_map unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。\nstack #include \u0026lt;stack\u0026gt;\n  创建\nstd::stack\u0026lt;int\u0026gt; values;   成员函数\n   成员函数 功能     empty() 当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false。   size() 返回 stack 栈中存储元素的个数。   top() 返回一个栈顶元素的引用，类型为 T\u0026amp;。如果栈为空，程序会报错。   push(const T\u0026amp; val) 先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。   push(T\u0026amp;\u0026amp; obj) 以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。   pop() 弹出栈顶元素。   emplace(arg\u0026hellip;) arg\u0026hellip; 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素。   swap(stack \u0026amp; other_stack) 将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。      queue #include \u0026lt;queue\u0026gt;\n  创建\nstd::queue\u0026lt;int\u0026gt; values;   成员方法\n   成员函数 功能     empty() 如果 queue 中没有元素的话，返回 true。   size() 返回 queue 中元素的个数。   front() 返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。   back() 返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。   push(const T\u0026amp; obj) 在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。   emplace() 在 queue 的尾部直接添加一个元素。   push(T\u0026amp;\u0026amp; obj) 以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。   pop() 删除 queue 中的第一个元素。   swap(queue \u0026amp;other_queue) 将两个 queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。      C++常用算法 sort() "
},
{
	"uri": "http://example.org/bigdata/hadoop/",
	"title": "Hadoop",
	"tags": [],
	"description": "",
	"content": "Hadoop系统简介  Hadoop 是一种分析和处理大数据的软件平台，是一个用 Java 语言实现的 Apache 的开源软件框架，在大量计算机组成的集群中实现了对海量数据的分布式计算。\n Hadoop 采用 MapReduce 分布式计算框架，根据 GFS 原理开发了 HDFS（分布式文件系统），并根据 BigTable 原理开发了 HBase 数据存储系统。\n Hadoop 和 Google 内部使用的分布式计算系统原理相同，其开源特性使其成为分布式计算系统的事实上的国际标准。\n Yahoo、Facebook、Amazon，以及国内的百度、阿里巴巴等众多互联网公司都以 Hadoop 为基础搭建了自己的分布式计算系统。\n Hadoop 是一个基础框架，允许用简单的编程模型在计算机集群上对大型数据集进行分布式处理。它的设计规模从单一服务器到数千台机器，每个服务器都能提供本地计算和存储功能，框架本身提供的是计算机集群高可用的服务，不依靠硬件来提供高可用性。用户可以在不了解分布式底层细节的情况下，轻松地在 Hadoop 上开发和运行处理海量数据的应用程序。低成本、高可靠、高扩展、高有效、高容错等特性让 hadoop 成为最流行的大数据分析系统。\nHadoop 生态圈 其中，HDFS是一个提供高可用的获取应用数据的分布式文件系统；MapReduce是一个并行处理大数据集的编程模型。\nHDFS 两类节点：\n NameNode，名称节点 Master DataNode，数据节点 Worker  HDFS 总的设计思想是分而治之，即将大文件和大批量文件分布式存放在大量独立的服务器上，以便采取分而治之的方式对海量数据进行运算分析。\nHDFS 是一个主/从体系结构，从最终用户的角度来看，它就像传统的文件系统一样，可以通过目录路径对文件执行 CRUD（Create、Read、Update 和 Delete）操作。但由于分布式存储的性质，HDFS 集群拥有一个 NameNode 和一些 DataNode。NameNode 管理文件系统的元数据，DataNode 存储实际的数据。\n客户端通过联系 NameNode 来获取文件的元数据，而真正的文件 I/O 操作是直接和 DataNode 交互进行的。\nHDFS 主要针对“一次写入，多次读取”的应用场景，不适合实时交互性很强的应用场景，也不适合存储大量小文件。\nHDFS的基本思想\nHDFS 是个抽象层，底层依赖很多独立的服务器，对外提供统一的文件管理功能。基本架构如图所示\n例如，用户访问 HDFS 中的 /a/b/c.mpg 这个文件时，HDFS 负责从底层的相应服务器中读取该文件，然后返回给用户，这样用户就只需和 HDFS 打交道，而不用关心这个文件是如何存储的。\n为了解决存储结点负载不均衡的问题，HDFS 首先把一个文件分割成多个块，然后再把这些文件块存储在不同服务器上。这种方式的优势就是不怕文件太大，并且读文件的压力不会全部集中在一台服务器上，从而可以避免某个热点文件会带来的单机负载过高的问题。\n文件分块存储：\n为了保证文件的可靠性，避免一台机器坏了导致丢失文件的情况，HDFS会把每个文件块进行多个备份，一般情况下是备份3份，如图所示：\n采用分块多副本存储方式后，HDFS 文件的可靠性就大大增强了，即使某个服务器出现故障，也仍然可以完整读取文件，该方式同时还带来一个很大的好处，就是增加了文件的并发访问能力。例如，多个用户读取这个文件时，都要读取块 1，HDFS 可以根据服务器的繁忙程度，选择从哪台服务器读取块 1。\n为了管理文件，HDFS 需要记录维护一些元数据，也就是关于文件数据信息的数据，如 HDFS 中存了哪些文件，文件被分成了哪些块，每个块被放在哪台服务器上等。\nHDFS 把这些元数据抽象为一个目录树，来记录这些复杂的对应关系。这些元数据由一个单独的模块进行管理，这个模块叫作名称结点（NameNode）。存放文件块的真实服务器叫作数据结点（DataNode）。\nHDFS整体架构\nHDFS 是一个主从 Master/Slave 架构。一个 HDFS 集群包含一个 NameNode，这是一个 Master Server，用来管理文件系统的命名空间，以及调节客户端对文件的访问。一个 HDFS 集群还包括多个 DataNode，用来存储数据。\nHDFS 会对外暴露一个文件系统命名空间，并允许用户数据以文件的形式进行存储。在内部，一个文件被分成多个块并且这些块被存储在一组 DataNode 上。\n1）NameNode\n文件的元数据采用集中式存储方案存放在 NameNode 当中。NameNode 负责执行文件系统命名空间的操作，如打幵、关闭、重命名文件和目录。NameNode 同时也负责将数据块映射到对应的 DataNode 中。\n2） DataNode\nDataNode 是文件系统的工作结点。它们根据需要存储并检索数据块，并且定期向 NameNode 发送他们所存储的块的列表。文件数据块本身存储在不同的 DataNode 当中，DataNode 可以分布在不同机架上。\nDataNode 负责服务文件系统客户端发出的读/写请求。DataNode 同时也负责接收 NameNode 的指令来进行数据块的创建、删除和复制。\n3）Client\nHDFS 的 Client 会分别访问 NameNode 和 DataNode 以获取文件的元信息及内容。HDFS 集群的 Client 将直接访问 NameNode 和 DataNode，相关数据会直接从 NameNode 或者 DataNode 传送到客户端。\nNameNode 和 DataNode 都是被设计为在普通 PC 上运行的软件程序。HDFS 是用Java语言实现的，任何支持 Java 语言的机器都可以运行 NameNode 或者 DataNode。Java 语言本身的可移植性意味着 HDFS 可以被广泛地部署在不同的机器上。\n一个典型的部署就是，集群中的一台专用机器运行 NameNode，集群中的其他机器每台运行一个 DataNode 实例。该架构并不排除在同一台机器上运行多个 DataNode 实例的可能，但在实际的部署中很少会这么做。\n单一 NameNode 的设计极大地简化了集群的系统架构，它使得所有 HDFS 元数据的仲裁和存储都由单一 NameNode 来决定，避免了数据不一致性的问题。\nHDFS数据复制\nHDFS 可以跨机架、跨机器，可靠地存储海量文件。HDFS 把每个文件存储为一系列的数据块，除了最后一个数据块以外，一个文件的所有数据块都是相同大小的。\n为了容错，一个文件的数据块会被复制。对于每个文件来说，文件块大小和复制因子都是可配置的。应用程序可以声明一个文件的副本数。复制因子可以在文件创建时声明，并且可以在以后修改。\nNameNode 控制所有的数据块的复制决策，如下图所示。它周期性地从集群中的 DataNode 中收集心跳和数据块报告。收集到心跳则意味着 DataNode 正在提供服务。收集到的数据块报告会包含相应 DataNode 上的所有数据块列表。\n通用场景下，当复制因子是 3 时，HDFS 的放置策略是将一个副本放置到本地机架的一个结点上，另一个放在本地机架的不同结点上，最后一个放在不同机架的不同结点上。机架不可用的概率要比结点不可用的概率低很多，这一策略并不影响数据可靠性和可用性。\n当一切运行正常时，DataNode 会周期性发送心跳信息给 NameNode（默认是每 3 秒钟一次）。如果 NameNode 在预定的时间内没有收到心跳信息（默认是 10 分钟），就会认为 DataNode 出现了问题，这时候就会把该 DataNode 从集群中移除，并且启动一个进程去恢复数据。DataNode 脱离集群的原因有多种，如硬件故障、主板故障、电源老化和网络故障等。\nMapReduce   Map\n对集合中的每个元素进行同一个操作。如果想把表单里每个单元格乘以二，那么把这个函数单独地应用在每个单元格上的操作就属于映射（Map)。\n  Reduce\n  ​\t遍历集合中的元素来返回一个综合的结果。如果想找出表单里所有数字的总和，那么输出表单里一列数字的总和的任务就属于化简（Reduce)。\nMapReduce基本思想\n  分而治之\n并行计算的第一个重要问题是如何划分计算任务或者计算数据以便对划分的子任务或数据块同时进行计算。但是，一些计算问题的前后数据项之间存在很强的依赖关系，无法进行划分，只能串行计算。\n对于不可拆分的计算任务或相互间有依赖关系的数据无法进行并行计算。一个大数据若可以分为具有同样计算过程的数据块，并且这些数据块之间不存在数据依赖关系，则提高处理速度的最好办法就是并行计算。\n  抽象模型：Map函数和Reduce函数\nMap 函数对一组数据元素进行某种重复式的处理，Reduce 函数对 Map 函数的中间结果进行某种进一步的结果整理。\n1) Map:\u0026lt;k1,v1\u0026gt;List(\u0026lt;K2,V2\u0026gt;)\n输入：键值对\u0026lt;k1,v1\u0026gt;表示的数据。\n处理：数据记录将以“键值对”形式传入 Map 函数；Map 函数将处理这些键值对，并以另一种键值对形式输出中间结果 List(\u0026lt;K2,V2\u0026gt;)。\n输出：键值对List(\u0026lt;K2,V2\u0026gt;)示的一组中间数据。\n2) Reduce:\u0026lt;K2,List(V2)\u0026gt;→List(\u0026lt;K3,V3\u0026gt;)\n输入：由 Map 输出的一组键值对 List(\u0026lt;K2,V2\u0026gt;)将被进行合并处理，同样主键下的不同数值会合并到一个列表List(V2)中，故 Reduce 的输入为\u0026lt;K2,List(V2)\u0026gt;。\n处理：对传入的中间结果列表数据进行某种整理或进一步的处理，并产生最终的输出结果List(\u0026lt;K3,V3\u0026gt;)。\n输出：最终输出结果List(\u0026lt;K3,V3\u0026gt;)。\n   函数 输入 输出 注解     Map Map\u0026lt;k1,V1\u0026gt; List(\u0026lt;k1,V2\u0026gt;) 将输入数据集分解成一批\u0026lt;key,value\u0026gt;对，然后进行处理；每一个\u0026lt;key,value\u0026gt;输入，Map 会输出一批\u0026lt;K2,V2\u0026gt;   Reduce \u0026lt;k2,List(V2)\u0026gt; \u0026lt;K3,V3\u0026gt; MapReduce 框架会把 Map 的输出，按 key 归类为 \u0026lt;K2,List(V2)\u0026gt;。List(V2) 是一批属于同一个 K2 的 value      并行自动化并隐藏底层细节\nMapReduce 提供了一个统一的计算框架，来完成计算任务的划分和调度，数据的分布存储和划分，处理数据与计算任务的同步，结果数据的收集整理，系统通信、负载平衡、计算性能优化、系统结点出错检测和失效恢复处理等。\nMapReduce 通过抽象模型和计算框架把需要做什么与具体怎么做分开了，为程序员提供了一个抽象和高层的编程接口和框架，程序员仅需要关心其应用层的具体计算问题，仅需编写少量的处理应用本身计算问题的程序代码。\n与具体完成并行计算任务相关的诸多系统层细节被隐藏起来，交给计算框架去处理：从分布代码的执行，到大到数千个，小到单个的结点集群的自动调度使用。\nMapReduce 计算架构提供的主要功能包括以下几点。\n1）任务调度\n提交的一个计算作业（Job)将被划分为很多个计算任务（Tasks)。\n任务调度功能主要负责为这些划分后的计算任务分配和调度计算结点（Map 结点或 Reduce 结点），同时负责监控这些结点的执行状态，以及 Map 结点执行的同步控制，也负责进行一些计算性能优化处理。例如，对最慢的计算任务采用多备份执行，选最快完成者作为结果。\n2）数据/程序互定位\n为了减少数据通信量，一个基本原则是本地化数据处理，即一个计算结点尽可能处理其本地磁盘上分布存储的数据，这实现了代码向数据的迁移。\n当无法进行这种本地化数据处理时，再寻找其他可用结点并将数据从网络上传送给该结点（数据向代码迁移)，但将尽可能从数据所在的本地机架上寻找可用结点以减少通信延迟。\n3）出错处理\n在以低端商用服务器构成的大规模 MapReduce 计算集群中，结点硬件（主机、兹盘、内存等）出错和软件有缺陷是常态。因此，MapReduce 架构需要能检测并隔离出错结点，并调度分配新的结点接管出错结点的计算任务。\n4）分布式数据存储与文件管理\n海量数据处理需要一个良好的分布数据存储和文件管理系统作为支撑，该系统能够把海量数据分布存储在各个结点的本地磁盘上，但保持整个数据在逻辑上成为一个完整的数据文件。\n为了提供数据存储容错机制，该系统还要提供数据块的多备份存储管理能力。\n5）Combiner 和 Partitioner\n为了减少数据通信开销，中间结果数据进入 Reduce 结点前需要进行合并（Combine）处理，即把具有同样主键的数据合并到一起避免重复传送。\n一个 Reduce 结点所处理的数据可能会来自多个 Map 结点，因此，Map 结点输出的中间结果需使用一定的策略进行适当的划分（Partition）处理，保证相关数据发送到同一个 Reduce 结点上。\n  MapReduce架构\nHadoop的MapReduce与HDFS集群架构：\nMapReduce工作流程\nWordCount\n 分割   Map   Map端排序及Combine过程   Reduce端排序及输出结果  MapReduce作业执行流程\n 提交作业  客户端向 JobTracker 提交作业。首先，用户需要将所有应该配置的参数根据需求配置好。作业提交之后，就会进入自动化执行。在这个过程中，用户只能监控程序的执行情况和强制中断作业，但是不能对作业的执行过程进行任何干预。提交作业的基本过程如下。\n**1）**客户端通过 Runjob() 方法启动作业提交过程。\n**2）**客户端通过 JobTracker 的 getNewJobId() 请求一个新的作业 ID。\n**3）**客户端检查作业的输出说明，计算作业的输入分片等，如果有问题，就抛出异常，如果正常，就将运行作业所需的资源（如作业 Jar 文件，配置文件，计算所得的输入分片等）复制到一个以作业 ID 命名的目录中。\n**4）**通过调用 JobTracker 的 submitjob() 方法告知作业准备执行。\n初始化作业  JobTracker 在 JobTracker 端开始初始化工作，包括在其内存里建立一系列数据结构，来记录这个 Job 的运行情况。\n**1）**JobTracker 接收到对其 submitJob() 方法的调用后，就会把这个调用放入一个内部队列中，交由作业调度器进行调度。初始化主要是创建一个表示正在运行作业的对象，以便跟踪任务的状态和进程。\n**2）**为了创建任务运行列表，作业调度器首先从 HDFS 中获取 JobClient 已计算好的输入分片信息，然后为每个分片创建一个 MapTask，并且创建 ReduceTask。\n分配任务  JobTracker 会向 HDFS 的 NameNode 询问有关数据在哪些文件里面，这些文件分别散落在哪些结点里面。JobTracker 需要按照“就近运行”原则分配任务。\nTaskTracker 定期通过“心跳”与 JobTracker 进行通信，主要是告知 JobTracker 自身是否还存活，以及是否已经准备好运行新的任务等。\nJobTracker 接收到心跳信息后，如果有待分配的任务，就会为 TaskTracker 分配一个任务，并将分配信息封装在心跳通信的返回值中返回给 TaskTracker。\n对于 Map 任务，JobTracker 通常会选取一个距离其输入分片最近的 TaskTracker，对于 Reduce 任务，JobTracker 则无法考虑数据的本地化。\n执行任务  **1）**TaskTracker 分配到一个任务后，通过 HDFS 把作业的 Jar 文件复制到 TaskTracker 所在的文件系统，同时，TaskTracker 将应用程序所需要的全部文件从分布式缓存复制到本地磁盘。TaskTracker 为任务新建一个本地工作目录，并把 Jar 文件中的内容解压到这个文件夹中。\n**2）**TaskTracker 启动一个新的 JVM 来运行每个任务（包括 Map 任务和 Reduce 任务），这样，JobClient 的 MapReduce 就不会影响 TaskTracker 守护进程。任务的子进程每隔几秒便告知父进程它的进度，直到任务完成。\n进程和状态的更新  一个作业和它的每个任务都有一个状态信息，包括作业或任务的运行状态，Map 任务和 Reduce 任务的进度，计数器值，状态消息或描述。任务在运行时，对其进度保持追踪。\n这些消息通过一定的时间间隔由 ChildJVM 向 TaskTracker 汇聚，然后再向 JobTracker 汇聚。JobTracker 将产生一个表明所有运行作业及其任务状态的全局视图，用户可以通过 Web UI 进行查看。JobClient 通过每秒查询 JobTracker 来获得最新状态，并且输出到控制台上。\n作业的完成  当 JobTracker 接收到的这次作业的最后一个任务已经完成时，它会将 Job 的状态改为“successful”。当 JobClient 获取到作业的状态时，就知道该作业已经成功完成，然后 JobClient 打印信息告知用户作业已成功结束，最后从 Runjob() 方法返回。\nShuffle过程\nHadoop MapReduce 的 Shuffle 阶段是指从 Map 的输出开始，包括系统执行排序，以及传送 Map 输出到 Reduce 作为输入的过程。\n排序阶段是指对 Map 端输出的 Key 进行排序的过程。不同的 Map 可能输出相同的 Key，相同的 Key 必须发送到同一个 Reduce 端处理。Shuffle 阶段可以分为 Map 端的 Shuffle 阶段和 Reduce 端的 Shuffle 阶段。\n Map 端的 Shuffle 阶段  1）每个输入分片会让一个 Map 任务来处理，默认情况下，以 HDFS 的一个块的大小（默认为 64MB）为一个分片。Map 函数开始产生输出时，并不是简单地把数据写到磁盘中，因为频繁的磁盘操作会导致性能严重下降。它的处理过程是把数据首先写到内存中的一个缓冲区， 并做一些预排序，以提升效率。\n**2）**每个 Map 任务都有一个用来写入输出数据的循环内存缓冲区（默认大小为 100MB)，当缓冲区中的数据量达到一个特定阈值（默认是 80%）时，系统将会启动一个后台线程，把缓冲区中的内容写到磁盘中（即 Spilt阶段)。在写磁盘过程中，Map 输出继续被写到缓冲区中，但如果在此期间缓冲区被填满，那么 Map 任务就会阻塞直到写磁盘过程完成。\n3）在写磁盘前，线程首先根据数据最终要传递到的 Reduce 任务把数据划分成相应的分区（Partition）。在每个分区中，后台线程按 Key 进行排序，如果有一个 Combiner，便会在排序后的输出上运行。\n**4）**一旦内存缓冲区达到溢出写的阈值，就会创建一个溢出写文件，因此在 Map 任务完成其最后一个输出记录后，便会有多个溢出写文件。在 Map 任务完成前，溢出写文件被合并成一个索引文件和数据文件（多路归并排序）（Sort 阶段)。\n**5）**溢出写文件归并完毕后，Map 任务将删除所有的临时溢出写文件，并告知 TaskTracker 任务已完成，只要其中一个 Map 任务完成，Reduce 任务就会开始复制它的输出（Copy 阶段)。\n**6）**Map 任务的输出文件放置在运行 Map 任务的 TaskTracker 的本地磁盘上，它是运行 Reduce 任务的 TaskTracker 所需要的输入数据。\nReduce 端的 Shuffle 阶段  **1）**Reduce 进程启动一些数据复制线程，请求 Map 任务所在的 TaskTracker 以获取输出文件（Copy 阶段）。\n**2）**将 Map 端复制过来的数据先放入内存缓冲区中，Merge 有 3 种形式，分别是内存到内存，内存到磁盘，磁盘到磁盘。默认情况下，第一种形式不启用，第二种形式一直在运行（Spilt阶段），直到结束，第三种形式生成最终的文件（Merge 阶段）。\n**3）**最终文件可能存在于磁盘中，也可能存在于内存中，但是默认情况下是位于磁盘中的。当 Reduce 的输入文件已定，整个 Shuffle 阶段就结束了，然后就是 Reduce 执行，把结果放到 HDFS 中（Reduce 阶段）。\n"
},
{
	"uri": "http://example.org/programs/joyyourmind/",
	"title": "JoyYourMind",
	"tags": [],
	"description": "",
	"content": "“悦君”小程序 本程序理念见简历“微信小程序”\n感谢 武汉纺织大学2021届黄佳，范美琳同学\n开个坑在这放着，让自己有个做的动力~~\n"
},
{
	"uri": "http://example.org/algorithm/leetcode/",
	"title": "LeetCode",
	"tags": [],
	"description": "",
	"content": "1、两数之和   题目描述\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n示例 2：\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n示例 3：\n输入：nums = [3,3], target = 6\n输出：[0,1]\n提示：\n2 \u0026lt;= nums.length \u0026lt;= 104\n-109 \u0026lt;= nums[i] \u0026lt;= 109\n-109 \u0026lt;= target \u0026lt;= 109\n只会存在一个有效答案\n进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n  代码1\nclass Solution { public:  vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) {  bool flag=false;  for(int i=0;i\u0026lt;nums.size();i++){  for(int j=0;j\u0026lt;nums.size() \u0026amp;\u0026amp; i!=j ;j++){  if(nums[i]+nums[j] == target){  return {i,j};  }  }  }  return {};  } };   思路分析1\n  ​\t暴力枚举\n​\t时间复杂度O(n²)\n​\t空间复杂度O(1)\n  代码2\nclass Solution { public:  vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) {  unordered_map\u0026lt;int, int\u0026gt; hashtable;  for (int i = 0; i \u0026lt; nums.size(); ++i) {  auto it = hashtable.find(target - nums[i]);  if (it != hashtable.end()) {  return {it-\u0026gt;second, i};  }  hashtable[nums[i]] = i;  }  return {};  } };   思路分析2\n  ​\t哈希表，元素值作为索引，元素在nums中的下标作为值\n​\tunorder_map内部实现了一个哈希表，因此查找速度非常快，遇到查找问题，unorder_map会比较高效。\n2、两数相加   题目描述\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例 1：\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807.\n示例 2：\n输入：l1 = [0], l2 = [0]\n输出：[0]\n示例 3：\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n提示：\n每个链表中的节点数在范围 [1, 100] 内\n0 \u0026lt;= Node.val \u0026lt;= 9\n题目数据保证列表表示的数字不含前导零\n  代码\nclass Solution { public:  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {  ListNode *head = NULL, *p; //头指针，工作指针  int carry = 0, sum;//进位位，和   while (l1 != NULL || l2 != NULL || carry != 0) {  //直接用或，包括了两个都没有算完，还剩一个，还剩进位位，共三种情况  sum = 0;  if (l1 != NULL) {  sum += l1-\u0026gt;val;  l1 = l1-\u0026gt;next;  }  //l1,l2不空的时候就加  if (l2 != NULL) {  sum += l2-\u0026gt;val;  l2 = l2-\u0026gt;next;  }  sum += carry;  carry = sum / 10; //进位  sum %= 10;  ListNode *newNode = new ListNode(sum);  if (head == NULL) {  head = newNode;  p = newNode;  } else{  p-\u0026gt;next = newNode;  p = p-\u0026gt;next; //尾插  }  }  return head;  } };   思路分析\n链表相关：头指针、工作指针；尾插法\n进位位，三种情况\n  3、  题目描述 代码 思路分析  4、  题目描述 代码 思路分析  374、猜数字大小   题目描述\n猜数字游戏的规则如下：\n每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。\n如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。\n你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：\n-1：我选出的数字比你猜的数字小 pick \u0026lt; num\n1：我选出的数字比你猜的数字大 pick \u0026gt; num\n0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num\n返回我选出的数字。\n  代码\nclass Solution { public:  int guessNumber(int n) {  int left = 1, right = n;  while (left \u0026lt; right) { // 循环直至区间左右端点相同  int mid = left + (right - left) / 2; // 防止计算时溢出  if (guess(mid) \u0026lt;= 0) {  right = mid; // 答案在区间 [left, mid] 中  } else {  left = mid + 1; // 答案在区间 [mid+1, right] 中  }  }  // 此时有 left == right，区间缩为一个点，即为答案  return left;  } };   思路分析\n二分查找思想\n  704、二分查找   题目描述\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1:\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n示例 2:\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n提示：\n你可以假设 nums 中的所有元素是不重复的。\nn 将在 [1, 10000]之间。\nnums 的每个元素都将在 [-9999, 9999]之间。\n  代码\nclass Solution { public:  int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) {  // 返回target在nums中的下标，不存在就返回-1  int low = 0,high = nums.size()-1;  int mid;  while(low\u0026lt;=high) // low\u0026lt;=high,low\u0026lt;high或有样例不通过  {  mid = (low+high)/2; // 每次都要更新 mid  if(target\u0026lt;nums[mid])  high = mid-1;  else if(target\u0026gt;nums[mid])  low = mid+1;  else  return mid;  }  return -1;  } };   思路分析及问题\n改进：mid = low +((high-low)/2)\n在当low+high的结果大于表达式结果类型所能表示的最大值时会产生溢出\n小错误：\nlow\u0026lt;high会有样例不通过（可能正确答案就是low=high时的值）\n  "
},
{
	"uri": "http://example.org/programs/millenniumtemple/",
	"title": "MillenniumTemple",
	"tags": [],
	"description": "",
	"content": "“千禧寺”小程序 设计作者：彭雨薇 江汉大学\nhttps://www.canva.cn/design/DAEae4EubYs/faN11NrdqF_U7tQiF_aijQ/edit#1\n开个坑在这放着，让自己有个做的动力~~\n系统架构 "
},
{
	"uri": "http://example.org/algorithm/newcoder/",
	"title": "NewCoder",
	"tags": [],
	"description": "",
	"content": "AB1、[模板] 栈   题目描述\n描述 请你实现一个栈。 操作： push x：将 加x\\x 入栈，保证 x\\x 为 int 型整数。 pop：输出栈顶，并让栈顶出栈 top：输出栈顶，栈顶不出栈 输入描述： 第一行为一个正整数 n\\n ，代表操作次数。(1 \\leq n \\leq 100000)(1≤n≤100000) 接下来的 n\\n ，每行为一个字符串，代表一个操作。保证操作是题目描述中三种中的一种。  输出描述： 如果操作为push，则不输出任何东西。 如果为另外两种，若栈为空，则输出 \u0026#34;error“ 否则按对应操作输出。 示例1 输入： 6 push 1 pop top push 2 push 3 pop 复制 输出： 1 error 3   代码\n#include\u0026lt;stdio.h\u0026gt; int main() {  int n;  scanf(\u0026#34;%d\u0026#34;,\u0026amp;n);  char s[10];  int stack[n],i=0,num;  while(n--)  {  scanf(\u0026#34;%s\u0026#34;,\u0026amp;s);  if(s[1]==\u0026#39;u\u0026#39;)  {  scanf(\u0026#34;%d \u0026#34;,\u0026amp;num);  stack[i++]=num;  }  else if(s[1]==\u0026#39;o\u0026#39;)  {  if(s[0]==\u0026#39;p\u0026#39;)  {  if(i\u0026gt;0)  {  printf(\u0026#34;%d\\n\u0026#34;,stack[i-1]);  i--;  }  else{  printf(\u0026#34;error\\n\u0026#34;);  }  }  else if(s[0]==\u0026#39;t\u0026#39;)  {  if(i\u0026gt;0)  {  printf(\u0026#34;%d\\n\u0026#34;,stack[i-1]);  }  else{  printf(\u0026#34;error\\n\u0026#34;);  }  }  }  }  return 0; }   思路分析\n  ​\t直接用数组来表示栈，数组索引表示指针，i++即为入栈，i\u0026ndash;即为出栈\n"
},
{
	"uri": "http://example.org/algorithm/pat/",
	"title": "PAT",
	"tags": [],
	"description": "",
	"content": "2019-12-30——2020-03-30 乙1001 卡拉兹(Callatz)猜想   题目描述\n卡拉兹(Callatz)猜想：\n对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……\n我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？\n输入格式：\n每个测试输入包含 1 个测试用例，即给出正整数 n 的值。\n输出格式：\n输出从 n 计算到 1 需要的步数。\n输入样例：\n3\n输出样例：\n5\n  代码\n#include\u0026lt;iostream\u0026gt;using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; int count=0; while (n!=1) { \t//注意考虑n=1 \tcount += 1;  if(n%2==1) \t{  n=(3*n+1)/2;  }  else  {  n=n/2;  } } cout \u0026lt;\u0026lt; count \u0026lt;\u0026lt; endl; return 0; }   思路分析及问题\n  乙1002   题目描述\n读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。\n输入格式：\n每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 10100。\n输出格式：\n在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。\n输入样例：\n1234567890987654321123456789\n输出样例：\nyi san wu\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt; //向量 #include\u0026lt;map\u0026gt; //映射 #include\u0026lt;string\u0026gt; //字符串 using namespace std; int main() {  string n;  cin\u0026gt;\u0026gt;n;  int sum=0;  int i;  for(i=0;i\u0026lt;n.length();i++)  {  sum+=n[i]-\u0026#39;0\u0026#39;;  }    vector\u0026lt;int\u0026gt; subsum; //记录sum的各位数字  while(sum!=0)  {  subsum.push_back(sum%10); //向尾部添加元素，高位在队尾  sum=sum/10;  }   map\u0026lt;int,string\u0026gt; numpy; //0~9对应的拼音  numpy[0]=\u0026#34;ling\u0026#34;;  numpy[1]=\u0026#34;yi\u0026#34;;  numpy[2]=\u0026#34;er\u0026#34;;  numpy[3]=\u0026#34;san\u0026#34;;  numpy[4]=\u0026#34;si\u0026#34;;  numpy[5]=\u0026#34;wu\u0026#34;;  numpy[6]=\u0026#34;liu\u0026#34;;  numpy[7]=\u0026#34;qi\u0026#34;;  numpy[8]=\u0026#34;ba\u0026#34;;  numpy[9]=\u0026#34;jiu\u0026#34;;   vector\u0026lt;int\u0026gt;::iterator t; //向量的迭代器(指针)  for(t=--subsum.end();t!=subsum.begin();t--)  {  cout\u0026lt;\u0026lt;numpy[*t];  if(t!=subsum.end())  printf(\u0026#34; \u0026#34;);   }  cout\u0026lt;\u0026lt;numpy[*t];   return 0; }   思路分析及问题\n①输入数字位数超出long int范围,故需要以字符串形式输入\n②取每一位的值的时候根据索引取得的是字符，需要转换为数字(ASCII码，减去字符'0')\n③vector是一个类似List的东西，push_back是向队尾添加元素\n④map是映射关系\u0026lt;key,value\u0026gt;\n⑤iterator是迭代器(一个指向向量元素的指针)\n​\tend() 函数返回一个指向当前vector末尾元素的下一位置的迭代器.\n​\t要访问末尾元素,需要先将此迭代器减1。\n​\tback() 函数返回当前vector最末一个元素的引用\n  乙1003   题目描述\n“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。\n得到“答案正确”的条件是：\n 字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。  现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。\n输入格式：\n每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (\u0026lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。\n输出格式：\n每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。\n输入样例：\n8 PAT PAAT AAPATAA AAPAATAAAA xPATx PT Whatever APAAATAA\n输出样例：\nYES YES YES YES NO NO NO NO\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;using namespace std;  bool selectStr(string str,int length) {  //所有的字符应该都是PAT之一  for(int i=0; i\u0026lt;str.length(); i++)  {  if(str[i]!=\u0026#39;A\u0026#39; \u0026amp;\u0026amp; str[i]!=\u0026#39;P\u0026#39; \u0026amp;\u0026amp; str[i]!=\u0026#39;T\u0026#39;)  return false;  }  return true; } //判断字符串是否正确 string judge(string str) {  string result;  int length = str.length();  if(selectStr(str,length))  {  int lena = 0; //a中包含A的个数  int lenb = 0; //b中包含A的个数  int lenc = 0; //c中包含A的个数  for(int i=0;i\u0026lt;length;i++)  {  if(str[i]!=\u0026#39;P\u0026#39;)  lena++;  else  break;  } //aPbTc  for(int i=0,cnt=0;i\u0026lt;length;i++)  {  if(str[i]!=\u0026#39;T\u0026#39;)  cnt++; //T前所有字符个数  else  {  lenb = cnt-lena-1; //前面包括a中的A和\u0026#39;P\u0026#39;字符，所以减去lena再减1  lenc = length-cnt-1; //同理，c前面还有\u0026#39;T\u0026#39;字符  break;  }  }  if(lenb == 0)  //PT  result=\u0026#34;NO\u0026#34;;  else  {  if(lena*lenb == lenc)  {  result=\u0026#34;YES\u0026#34;;  }  else  {  result=\u0026#34;NO\u0026#34;;  }  }  //test  }  else  {  result=\u0026#34;NO\u0026#34;;  }  return result; }   int main() {  int n;  cin\u0026gt;\u0026gt;n;  string strs[n];  int i;  for(i=0;i\u0026lt;n;i++)  cin\u0026gt;\u0026gt;strs[i]; //输入字符串   string result[n];  for(i=0;i\u0026lt;n;i++)  result[i]=judge(strs[i]);    for(i=0;i\u0026lt;n;i++)  cout\u0026lt;\u0026lt;result[i]\u0026lt;\u0026lt;endl;    return 0; }   思路分析及问题\n  ​\t（1）第二个要求说明了a的长度和c的长度是相等的，所以我们可以列出一个等式：lena = lenc；\n​\t（2）第三个要求则说明，在第二个条件成立的条件下，将aPATc中的A字符换成b串，变为aPbTc。如果该字符串正确，那么aPbATca字符串也正确。仔细观察不难发现，P和A字符中间多加了一个A字符，而字符串末尾c串后面则加了一个a串。也就是说，c串后面加的a串的个数与P字符和T字符中间加入的A字符的个数相等。\n假设b含有lenb个A字符，那么新加入的A字符的个数就是（lenb-1）个(因为为了保证字符串正确，b中最起码要有一个A字符)。所以c串后面的a串个数也就是（lenb-1）个。所以可以列出一个式子： lenc = lenc+（lenb-1）*lena 。\n由第二个要求得出的式子 lena = lenc 带入得： lenc = lena + （lenb-1）*lena 。\n化简上式即为 ： lenc = lena * lenb\n乙1004   题目描述\n读入 n（\u0026gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。\n输入格式：\n每个测试输入包含 1 个测试用例，格式为\n第 1 行：正整数 n 第 2 行：第 1 个学生的姓名 学号 成绩 第 3 行：第 2 个学生的姓名 学号 成绩 \u0026hellip; \u0026hellip; \u0026hellip; 第 n+1 行：第 n 个学生的姓名 学号 成绩\n其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。\n输出格式：\n对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。\n输入样例：\n3 Joe Math990112 89 Mike CS991301 100 Mary EE990830 95\n输出样例：\nMike CS991301 Joe Math990112\n  代码\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;algorithm\u0026gt; //sort#define N 1024 using namespace std; struct student{  char name[11]; //注意‘\\0’  char num[11];  int score; }stu[N]; bool cmp(const student \u0026amp;a,const student \u0026amp;b){  return a.score\u0026lt;b.score; } int main(){  int n,flag=1;  while(flag){  cin \u0026gt;\u0026gt; n;  if(n\u0026gt;0) flag=0;  }   for(int i=0;i\u0026lt;n;i++){  cin \u0026gt;\u0026gt; stu[i].name \u0026gt;\u0026gt; stu[i].num \u0026gt;\u0026gt; stu[i].score;  }  sort(stu,stu+n,cmp); //sort方法进行排序  cout \u0026lt;\u0026lt; stu[n-1].name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; stu[n-1].num\u0026lt;\u0026lt; endl;  cout \u0026lt;\u0026lt; stu[0].name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; stu[0].num \u0026lt;\u0026lt; endl;  return 0; }   思路分析及问题\n  乙1005  题目描述 代码 思路分析及问题  乙1006   题目描述\n让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12\u0026hellip;n 来表示不为零的个位数字 n（\u0026lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。\n输入格式：\n每个测试输入包含 1 个测试用例，给出正整数 n（\u0026lt;1000）。\n输出格式：\n每个测试用例的输出占一行，用规定的格式输出 n。\n输入样例 1：\n234\n输出样例 1：\nBBSSS1234\n输入样例 2：\n23\n输出样例 2：\nSS123\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;sstream\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;map\u0026gt;using namespace std; // int to string string convertInt(int number)  {  stringstream ss;//create a stringstream  ss \u0026lt;\u0026lt; number;//add number to the stream  return ss.str();//return a string with the contents of the stream } int main() {  string str=\u0026#34;\u0026#34;;  int n;  cin\u0026gt;\u0026gt;n;  map\u0026lt;int,int\u0026gt; bitNum; //\u0026lt;第几位，数值\u0026gt;  if(n\u0026lt;1000)  {  int index = 1;  while(n!=0)  {  bitNum[index] = n%10 ; //\u0026lt;第一位，个位上的数\u0026gt;  index += 1;  n = n/10;  }  for(int i=index-1;i\u0026gt;=1;i--) //注意死循环  {  //从高位往低位   if(i==3)  {  for(int j=bitNum[3];j\u0026gt;=1;j--)  str.append(\u0026#34;B\u0026#34;);  }  if(i==2)  {  for(int j=bitNum[2];j\u0026gt;=1;j--)  str.append(\u0026#34;S\u0026#34;);  }  if(i==1)  {  for(int j=bitNum[1];j\u0026gt;=1;j--)  str.append(convertInt(bitNum[1]-j+1));  }  }  }  cout\u0026lt;\u0026lt;str;   return 0; }   思路分析及问题\n  乙1007   题目描述\n  代码\n  思路分析及问题\n质数(素数)是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。\n//判断是否是素数 bool isprime(int a) {  if(a \u0026lt;= 1) return false;  int Sqrt = sqrt((double)a);  for(int i = 2; i \u0026lt;= Sqrt; i++) {  if(a % i == 0)  return false; \t}  return true; }   乙1008   题目描述\n一个数组A中存有N（\u0026gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A0A1⋯A**N−1）变换为（A**N−M⋯A**N−1A0A1⋯A**N−M−1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？\n输入格式:\n每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。\n输出格式:\n在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。\n输入样例:\n6 2 1 2 3 4 5 6\n输出样例:\n5 6 1 2 3 4\n  代码\n#include\u0026lt;iostream\u0026gt;using namespace std; int a[0]; //声明一个长度为0的数组，后面可以进行扩展(长度不限于0) //交换数组中的两个元素 void swap(int *a,int i,int j) {  int tmp;  tmp=a[j];  a[j]=a[i];  a[i]=tmp; } int main() {  int n,m; //n个整数，m个位置  cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;  m=m%n; //m大于n时要取余  for(int i=0;i\u0026lt;n;i++)  cin\u0026gt;\u0026gt;a[i]; //输入n个数  if(m==1)  {  for(int i=0;i\u0026lt;n;i++)  swap(a,i,n-1);  }   else if(m==n-1)  {  for(int i=n-1;i\u0026gt;=1;i--)  swap(a,i,0);  }   else if(m\u0026lt;=n/2)  {  //交换a[0]至a[m-1]  for(int i=0;i\u0026lt;m;i++)  swap(a,i,i+n-m);   //交换a[m]至a[2m-1]  for(int i=m;i\u0026lt;2*m;i++)  swap(a,i,i+n-2*m);  }  else if(m\u0026gt;n/2)  {  for(int i=0;i\u0026lt;n-m;i++)  swap(a,i,i+n-m);   for(int i=n-m;i\u0026lt;m;i++)  swap(a,i,i+n-m);   for(int i=m;i\u0026lt;3*m-n;i++)  swap(a,i,i+2*n-3*m);  }   for(int i=0;i\u0026lt;n;i++)  {  cout\u0026lt;\u0026lt;a[i];  if(i!=n-1)  cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  }   return 0; }   思路分析及问题\n分情况讨论\n  乙1009   题目描述\n给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。\n输入格式：\n测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。\n输出格式：\n每个测试用例的输出占一行，输出倒序后的句子。\n输入样例：\nHello World Here I Come\n输出样例：\nCome I Here World Hello\n  代码\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; int main() {  string user; //用户的输入  getline(cin, user); //读取整行字符  int len = user.length();//计算字符串的长度  int k, p = len;  for (int i = len - 1; i \u0026gt;= 0; i--) \t//从后往前遍历  {  if (user[i] == \u0026#39; \u0026#39;)  {  for (k = i + 1; k \u0026lt;= p - 1; k++)  {  cout \u0026lt;\u0026lt; user[k];  }  cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  p = i;//保存当前找到的空格的位置  }  }  //到这里的时候还剩第一个没输出  for (int i = 0; i \u0026lt; p; i++)  cout \u0026lt;\u0026lt; user[i];  return 0; }   思路分析及问题\n  乙1010   题目描述\n设计函数求一元多项式的导数。（注：x**n（n为整数）的一阶导数为nx**n−1。）\n输入格式:\n以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。\n输出格式:\n以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 0 0。\n输入样例:\n3 4 -5 2 6 1 -2 0\n输出样例:\n12 3 -10 1 6 0\n  代码\n#include\u0026lt;iostream\u0026gt;using namespace std; int main() {  int a,b;  int x=1;  while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b)//输入 \t//从输入流循环读取a,b  {  if(b==0)  //常数项  break;//舍弃  if(!x)  cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  else  x=0; //第一轮之后x=0  cout\u0026lt;\u0026lt;a*b\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;b-1;  }  if(x) //没有输入  cout\u0026lt;\u0026lt;\u0026#34;0 0\u0026#34;;  return 0; }   思路分析及问题\n  乙1011   题目描述\n给定区间 [−231,231] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。\n输入格式：\n输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。\n输出格式：\n对每组测试用例，在一行中输出 Case #X: true 如果 A+B\u0026gt;C，否则输出 Case #X: false，其中 X 是测试用例的编号（从 1 开始）。\n输入样例：\n4 1 2 3 2 3 4 2147483647 0 2147483646 0 -2147483648 -2147483647\n输出样例：\nCase #1: false Case #2: true Case #3: true Case #4: false\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;using namespace std; string judge(long long int a, long long int b,long long int c) {  if(a+b\u0026gt;c)  return \u0026#34;true\u0026#34;;  else  return \u0026#34;false\u0026#34;; } using namespace std; int main() {  int n;  cin\u0026gt;\u0026gt;n;  long long int a[n],b[n],c[n];  for(int i=0;i\u0026lt;n;i++)  {  cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i];  }  for(int i=0;i\u0026lt;n;i++)  {  cout\u0026lt;\u0026lt;\u0026#34;Case #\u0026#34;\u0026lt;\u0026lt;i+1\u0026lt;\u0026lt;\u0026#34;: \u0026#34;\u0026lt;\u0026lt;judge(a[i],b[i],c[i])\u0026lt;\u0026lt;endl;  }  return 0; }   思路分析及问题\n[-231,231]超出了int类型的范围，用long long int\n  乙1012   题目描述\n给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：\n A1 = 能被 5 整除的数字中所有偶数的和； A2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n1−n2+n3−n4⋯； A3 = 被 5 除后余 2 的数字的个数； A4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位； A5 = 被 5 除后余 4 的数字中最大数字。  输入格式：\n每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。\n输出格式：\n对给定的 N 个正整数，按题目要求计算 A1~A5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。\n若其中某一类数字不存在，则在相应位置输出 N。\n输入样例 1：\n13 1 2 3 4 5 6 7 8 9 10 20 16 18\n输出样例 1：\n30 11 2 9.7 9\n输入样例 2：\n8 1 2 4 5 6 7 9 16\n输出样例 2：\nN 11 2 N 9\n  代码\n  ​\n#include\u0026lt;bits/stdc++.h\u0026gt;using namespace std; int a[1010]; //int a1[1010],a2[1010],a3[1010],a4[1010],a5[1010]; int main(){  int N;  scanf(\u0026#34;%d\u0026#34;,\u0026amp;N);  int t1=0,t2=0,t3=0,t4=0,t5=0;  int m=0;  int mm=1;  int nn=0;  for(int i=0;i\u0026lt;N;i++){  scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]);  if(a[i]%5==0\u0026amp;\u0026amp;a[i]%2==0) t1=t1+a[i];  else if(a[i]%5==1) {  nn++;  t2+=mm*a[i];  mm=mm*(-1);  }  else if(a[i]%5==2) t3++;  else if(a[i]%5==3) {  t4+=a[i];  m++;  }  else if(a[i]%5==4\u0026amp;\u0026amp;a[i]\u0026gt;t5) t5=a[i];  }  float t6=(float)t4/m;  // printf(\u0026#34;%d %d %d %.1f %d\\n\u0026#34;,t1,t2,t3,t6,t5);  if(t1==0) printf(\u0026#34;N \u0026#34;);  else printf(\u0026#34;%d \u0026#34;,t1);  if(nn==0) printf(\u0026#34;N \u0026#34;);  else printf(\u0026#34;%d \u0026#34;,t2);  if(t3==0) printf(\u0026#34;N \u0026#34;);  else printf(\u0026#34;%d \u0026#34;,t3);  if(t4==0) printf(\u0026#34;N \u0026#34;);  else printf(\u0026#34;%.1f \u0026#34;,t6);  if(t5==0) printf(\u0026#34;N\u0026#34;);  else printf(\u0026#34;%d\u0026#34;,t5);   return 0; }   思路分析及问题\n模拟、数学\n  乙1013  题目描述 代码 思路分析及问题  乙1014   题目描述\n大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s\u0026amp;hgsfdk d\u0026amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。\n输入格式：\n输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。\n输出格式：\n在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。\n输入样例：\n3485djDkxh4hhGE 2984akDfkkkkggEdsb s\u0026amp;hgsfdk d\u0026amp;Hyscvnm\n输出样例：\nTHU 14:04\n  代码\n  ​\n#include \u0026lt;iostream\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdio\u0026gt;using namespace std; int main() {  char s1[70],s2[70],s3[70],s4[70];  char week[7][4]={\u0026#34;MON\u0026#34;,\u0026#34;TUE\u0026#34;,\u0026#34;WED\u0026#34;,\u0026#34;THU\u0026#34;,\u0026#34;FRI\u0026#34;,\u0026#34;SAT\u0026#34;,\u0026#34;SUN\u0026#34;}; //二维数组存储多个字符串  cin\u0026gt;\u0026gt;s1\u0026gt;\u0026gt;s2\u0026gt;\u0026gt;s3\u0026gt;\u0026gt;s4;  int i,len1,len2,len3,len4;  len1=strlen(s1);  len2=strlen(s2);  len3=strlen(s3);  len4=strlen(s4);  for(i=0;i\u0026lt;len1\u0026amp;\u0026amp;i\u0026lt;len2;i++){  if(s1[i]==s2[i]\u0026amp;\u0026amp;s1[i]\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;s1[i]\u0026lt;=\u0026#39;G\u0026#39;)  //先判断相等，再判断是否是大写字母A~G(星期一~星期天)  {  printf(\u0026#34;%s \u0026#34;,week[s1[i]-\u0026#39;A\u0026#39;]);  break;  }  }//小时  //从i+1开始，再相等就直接是第二对相同的字符  for(i=i+1;i\u0026lt;len1\u0026amp;\u0026amp;i\u0026lt;len2;i++){  if(s1[i]==s2[i]){  if(s1[i]\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;s1[i]\u0026lt;=\u0026#39;9\u0026#39;){  printf(\u0026#34;%02d:\u0026#34;,s1[i]-\u0026#39;0\u0026#39;); //%02d: 宽度为2，不够就前面补零  break;  }else if(s1[i]\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;s1[i]\u0026lt;=\u0026#39;N\u0026#39;){  printf(\u0026#34;%02d:\u0026#34;,s1[i]-\u0026#39;A\u0026#39;+10);  break;  }  }  }//分钟  for(i=0;i\u0026lt;len3\u0026amp;\u0026amp;i\u0026lt;len4;i++){  if(s3[i]==s4[i]){  if((s3[i]\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;s3[i]\u0026lt;=\u0026#39;Z\u0026#39;)||(s3[i]\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;s3[i]\u0026lt;=\u0026#39;z\u0026#39;)) //英文字母  {  printf(\u0026#34;%02d\u0026#34;,i);  break;  }  }  }  return 0; }   思路分析及问题\n直接算，多用数组，二维数组，不要想复杂\n  乙1015   题目描述\n宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”\n现给出一批考生的德才分数，请根据司马光的理论给出录取排名。\n输入格式：\n输入第一行给出 3 个正整数，分别为：N（≤105），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（\u0026lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。\n随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。\n输出格式：\n输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。\n输入样例：\n14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60\n输出样例：\n12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90\n  代码\n#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;bits/stdc++.h\u0026gt;//student结构体 typedef struct{  char id[50];  int score1,score2,sum; //德分，才分和总分 }student;  //两个学生之间的比较 bool cmp(student a,student b){  if(a.sum \u0026gt;b.sum)  return true;  else if(a.sum ==b.sum){  if(a.score1 \u0026gt; b.score1)  return true;  else if(a.score1 == b.score1)  return (strcmp(a.id,b.id)\u0026gt;0)?false:true;  else if(a.score1 \u0026lt; b.score1)  return false;  }  else if(a.sum \u0026lt;b.sum)  return false;  return false; }  int main() {  int size,min,max;  scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;size,\u0026amp;min,\u0026amp;max); //N,L,H  student* best = (student*)malloc(sizeof(student)*size); //第一类  student* second = (student*)malloc(sizeof(student)*size); //第二类  student* less = (student*)malloc(sizeof(student)*size); //第三类  student* lessess = (student*)malloc(sizeof(student)*size); //第四类  int bestsize=0,secondsize=0,lesssize=0,lessesssize=0;  int temp1,temp2;  char id[50];  while(size--){  scanf(\u0026#34;%s %d %d\u0026#34;,id,\u0026amp;temp1,\u0026amp;temp2);  if(temp1\u0026gt;=max \u0026amp;\u0026amp; temp2 \u0026gt;=max){  //第一类  strcpy(best[bestsize].id,id);  best[bestsize].score1 = temp1;  best[bestsize].score2 = temp2;  best[bestsize++].sum = temp1+temp2;  }  else if(temp1 \u0026gt;=max \u0026amp;\u0026amp; temp2\u0026gt;=min){  //第二类  strcpy(second[secondsize].id,id);  second[secondsize].score1 = temp1;  second[secondsize].score2 = temp2;  second[secondsize++].sum = temp1+temp2;  }  else if(temp1 \u0026gt;=min \u0026amp;\u0026amp; temp2\u0026gt;=min){  if(temp1 \u0026gt;= temp2){  //第三类  strcpy(less[lesssize].id,id);  less[lesssize].score1 = temp1;  less[lesssize].score2 = temp2;  less[lesssize++].sum = temp1+temp2;  }  else{  //第四类  strcpy(lessess[lessesssize].id,id);  lessess[lessesssize].score1 = temp1;  lessess[lessesssize].score2 = temp2;  lessess[lessesssize++].sum = temp1+temp2;  }  }  }  std::sort(best,best+bestsize,cmp); //降序排序  std::sort(second,second+secondsize,cmp);  std::sort(less,less+lesssize,cmp);  std::sort(lessess,lessess+lessesssize,cmp);  printf(\u0026#34;%d\\n\u0026#34;,bestsize+secondsize+lesssize+lessesssize); //所有达到要求的人数  for(int i=0;i\u0026lt;bestsize;i++)  printf(\u0026#34;%s %d %d\\n\u0026#34;,best[i].id,best[i].score1,best[i].score2);  for(int i=0;i\u0026lt;secondsize;i++)  printf(\u0026#34;%s %d %d\\n\u0026#34;,second[i].id,second[i].score1,second[i].score2);  for(int i=0;i\u0026lt;lesssize;i++)  printf(\u0026#34;%s %d %d\\n\u0026#34;,less[i].id,less[i].score1,less[i].score2);  for(int i=0;i\u0026lt;lessesssize;i++)  printf(\u0026#34;%s %d %d\\n\u0026#34;,lessess[i].id,lessess[i].score1,lessess[i].score2);  return 0; }   思路分析及问题\n① 结构体的定义\n② 自定义cmp函数 sort(arr,arr+asize,cmp)\n③ malloc动态分配空间\n④ 循环输入，输入一个判断一个\n  乙1016   题目描述\n正整数 A 的“D**A（为 1 位整数）部分”定义为由 A 中所有 D**A 组成的新整数 P**A。例如：给定 A=3862767，D**A=6，则 A 的“6 部分”P**A 是 66，因为 A 中有 2 个 6。\n现给定 A、D**A、B、D**B，请编写程序计算 P**A+P**B。\n输入格式：\n输入在一行中依次给出 A、D**A、B、D**B，中间以空格分隔，其中 0\u0026lt;A,B\u0026lt;1010。\n输出格式：\n在一行中输出 P**A+P**B 的值。\n输入样例 1：\n3862767 6 13530293 3\n输出样例 1：\n399\n输入样例 2：\n3862767 1 13530293 8\n输出样例 2：\n0\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; int main() {  int DA,DB;  string A,B;  int PA=0,PB=0; // 0  int a[11],b[11];  cin\u0026gt;\u0026gt;A\u0026gt;\u0026gt;DA\u0026gt;\u0026gt;B\u0026gt;\u0026gt;DB;  int k1=0,k2=0;  for(int i=0;i\u0026lt;=A.length();i++)  {  if((A[i]-48)==DA) //找到给定的字符转换成数字  {  PA=PA+(A[i]-48)*pow(10,k1++);//计算出组成的新数字  }  }  for(int i=0;i\u0026lt;=B.length();i++)  {  if((B[i]-48)==DB)  {  PB=PB+(B[i]-48)*pow(10,k2++);  }  }  cout\u0026lt;\u0026lt;PA+PB\u0026lt;\u0026lt;endl;  return 0; }   思路分析及问题\n字符‘0’的ASCII码是48\ncmath库函数pow(a,b) = $a^b$\n  乙1017   题目描述\n本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。\n输入格式：\n输入在一行中依次给出 A 和 B，中间以 1 空格分隔。\n输出格式：\n在一行中依次输出 Q 和 R，中间以 1 空格分隔。\n输入样例：\n123456789050987654321 7\n输出样例：\n17636684150141093474 3\n  代码\n#include \u0026lt;iostream\u0026gt;using namespace std; int main() {  string s;  int a, t = 0, temp = 0;  cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; a;  int len = s.length();  t = (s[0] - \u0026#39;0\u0026#39;) / a;  if ((t != 0 \u0026amp;\u0026amp; len \u0026gt; 1) || len == 1)  cout \u0026lt;\u0026lt; t;  temp = (s[0] - \u0026#39;0\u0026#39;) % a;  for (int i = 1; i \u0026lt; len; i++) {  t = (temp * 10 + s[i] - \u0026#39;0\u0026#39;) / a;  cout \u0026lt;\u0026lt; t;  temp = (temp * 10 + s[i] - \u0026#39;0\u0026#39;) % a;  }  cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; temp;  return 0; }   思路分析及问题\n模拟除法运算过程\n  乙1018  题目描述 代码 思路分析及问题  乙1019   题目描述\n给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 6174，这个神奇的数字也叫 Kaprekar 常数。\n例如，我们从6767开始，将得到\n7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174 7641 - 1467 = 6174 \u0026hellip; \u0026hellip;\n现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。\n输入格式：\n输入给出一个 (0,104) 区间内的正整数 N。\n输出格式：\n如果 N 的 4 位数字全相等，则在一行内输出 N - N = 0000；否则将计算的每一步在一行内输出，直到 6174 作为差出现，输出格式见样例。注意每个数字按 4 位数格式输出。\n输入样例 1：\n6767\n输出样例 1：\n7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174\n输入样例 2：\n2222\n输出样例 2：\n2222 - 2222 = 0000\n  代码\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;stdio.h\u0026gt;using namespace std; int ascend,descend; //全局变量 void getNumber(int n){  int a[4]; //以数组得形式存储  for(int i = 0;i \u0026lt; 4; ++i){  a[i] = n % 10;  n = n / 10;  }  sort(a,a+4); //升序排序  descend = a[3]*1000 + a[2]*100 + a[1]*10 + a[0];//降序  ascend = a[0]*1000 + a[1]*100 + a[2]*10 + a[3];//升序 } int main(){  int n;  cin \u0026gt;\u0026gt; n ;  do{  getNumber(n);  n = descend - ascend;  printf(\u0026#34;%04d - %04d = %04d\\n\u0026#34;,descend,ascend,n); //%04d:格式控制字符串 （0000）  if(ascend == descend){  break;  }  //6174是一个测试点  }while( n != 6174);  return 0; }   思路分析及问题\n  乙1020   题目描述\n月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。\n注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。\n输入格式：\n每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。\n输出格式：\n对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。\n输入样例：\n3 20 18 15 10 75 72 45\n输出样例：\n94.50\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;algorithm\u0026gt;using namespace std; int main() {  int n;  double D, sum = 0, d;  cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; D;  vector\u0026lt;double\u0026gt; cake(n),list;  for (int i = 0; i \u0026lt; n; i++)  cin \u0026gt;\u0026gt; cake[i];  for (int i = 0; i \u0026lt; n; i++) {  //遍历每一种月饼  cin \u0026gt;\u0026gt; d;  for (int j = 0; j \u0026lt; cake[i]; j++)  //每一万吨  list.push_back(d /cake[i]);  }  sort(list.begin(), list.end(), greater\u0026lt;double\u0026gt;()); //降序排序  for (int i = 0; i \u0026lt; D\u0026amp;\u0026amp;i\u0026lt;list.size(); i++) //累加前D万吨的和就是最大收益  sum += list[i];  printf(\u0026#34;%0.2lf\u0026#34;, sum);  return 0; }   思路分析及问题\n  乙1021   题目描述\n给定一个 k 位整数 N=d**k−110k−1+⋯+d1101+d0 (0≤d**i≤9, i=0,⋯,k−1, d**k−1\u0026gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。\n输入格式：\n每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。\n输出格式：\n对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。\n输入样例：\n100311\n输出样例：\n0:2 1:3 3:1\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt; using namespace std; int main() {  int a[10]={0,0,0,0,0,0,0,0,0,0}; //索引代表0~9  string n;  cin\u0026gt;\u0026gt;n;  for(int i=0;i\u0026lt;n.length();i++)  a[n[i]-\u0026#39;0\u0026#39;]+=1;  for(int i=0;i\u0026lt;10;i++)  if(a[i]!=0)  cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;endl;  return 0; }   思路分析及问题\n  ​\t哈希表\n乙1022   题目描述\n输入两个非负 10 进制整数 A 和 B (≤230−1)，输出 A+B 的 D (1\u0026lt;D≤10)进制数。\n输入格式：\n输入在一行中依次给出 3 个整数 A、B 和 D。\n输出格式：\n输出 A+B 的 D 进制数。\n输入样例：\n123 456 8\n输出样例：\n1103\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt;using namespace std; int main() {  int A,B,D;  cin\u0026gt;\u0026gt;A\u0026gt;\u0026gt;B\u0026gt;\u0026gt;D;  int sum=A+B;  if(sum==0)  cout\u0026lt;\u0026lt;0;  if(D==10)  cout\u0026lt;\u0026lt;sum;  else  {  int mod;  vector\u0026lt;int\u0026gt; mods;  while(sum!=0)  {  mod=sum%D;  mods.push_back(mod); //D进制数得低位在前  sum=sum/D;  }  for(vector\u0026lt;int\u0026gt;::reverse_iterator it=mods.rbegin();it!=mods.rend();it++)  cout\u0026lt;\u0026lt;*it;  }  return 0; }   思路分析及问题\n模拟求D进制数得计算过程\n  乙1023   题目描述\n给定数字 0-9 各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定两个 0，两个 1，三个 5，一个 8，我们得到的最小的数就是 10015558。\n现给定数字，请编写程序输出能够组成的最小的数。\n输入格式：\n输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。\n输出格式：\n在一行中输出能够组成的最小的数。\n输入样例：\n2 2 0 0 0 3 0 0 1 0\n输出样例：\n10015558\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt;using namespace std; int main() {  int a[10];  vector\u0026lt;int\u0026gt; number;  for(int i=0;i\u0026lt;10;i++)  cin\u0026gt;\u0026gt;a[i];  for(int i=1;i\u0026lt;10;i++)  {  if(a[i]!=0)  {  //第一位为i  number.push_back(i);  a[i]-=1; //i的个数减一  break;  }  }  for(int i=0;i\u0026lt;10;i++)  {  while(a[i]!=0)  {  number.push_back(i);  a[i]-=1;  }  }   for(vector\u0026lt;int\u0026gt;::iterator it=number.begin();it!=number.end();it++)  {  cout\u0026lt;\u0026lt;*it;  }  return 0; }   思路分析及问题\n  乙1024   题目描述\n科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式 [+-][1-9].[0-9]+E[+-][0-9]+，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。\n现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。\n输入格式：\n每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 A。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。\n输出格式：\n对每个测试用例，在一行中按普通数字表示法输出 A，并保证所有有效位都被保留，包括末尾的 0。\n输入样例 1：\n+1.23400E-03\n输出样例 1：\n0.00123400\n输入样例 2：\n-1.2E+10\n输出样例 2：\n-12000000000\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;cstring\u0026gt;using namespace std; int main() {  string str;  cin\u0026gt;\u0026gt;str;  int a[10000]={0},b[10000];//系数 指数  int suma=0,sumb=0; //系数去掉.之后的值 指数去掉.之后的值  char yi,er=\u0026#39; \u0026#39;; //第一个正负号 第二个正负号  int n= str.length(),k=0,e=0,k1=0;  yi = str[0];  for(int i=1;i\u0026lt;n;i++)  {  if(str[i]==\u0026#39;E\u0026#39;)  {  er = str[i+1];//读入第二个正负号  k1=i+2;//记录指数开始的位数  break;  }  if(str[i]\u0026lt;=\u0026#39;9\u0026#39;\u0026amp;\u0026amp;str[i]\u0026gt;=\u0026#39;0\u0026#39;)  {  a[k]=str[i]-\u0026#39;0\u0026#39;;  suma = suma*10+a[k];  k++;  }  }  for(int i=k1;i\u0026lt;n;i++)//记录一下指数  {  b[e]=str[i]-\u0026#39;0\u0026#39;;  sumb = sumb*10+b[e];  e++;  }  if(yi==\u0026#39;-\u0026#39;) cout\u0026lt;\u0026lt;\u0026#34;-\u0026#34;;//当第一个符号是符号 需要输出“-”  if (sumb ==0)  { //当指数为0  cout\u0026lt;\u0026lt;a[0]\u0026lt;\u0026lt;\u0026#34;.\u0026#34;;  for(int i=1;i\u0026lt;k;i++)  {  cout\u0026lt;\u0026lt;a[i];  }  }  if (sumb !=0)  { //指数不为0  if(er == \u0026#39;+\u0026#39;)  {  if(sumb\u0026gt;=k-1)  { //第二个符号为+ 且指数值大于等于小数位数 1.2*10^4补零  for(int i=0 ;i\u0026lt;=sumb;i++)  {  cout\u0026lt;\u0026lt;a[i];  }  }  else  { //第二个符号为+ 且指数值小于小数位数 1.2000000000000*10^4不补零  for(int i=0 ;i\u0026lt;=sumb;i++)  {  cout\u0026lt;\u0026lt;a[i];  }  cout\u0026lt;\u0026lt;\u0026#34;.\u0026#34;;  for(int i=sumb+1;i\u0026lt;k;i++)  {  cout\u0026lt;\u0026lt;a[i];  }  }  }  if (er ==\u0026#39;-\u0026#39;)  { //第二个符号为-  cout\u0026lt;\u0026lt;\u0026#34;0.\u0026#34;;  sumb --;  while((sumb)!=0)  {  cout\u0026lt;\u0026lt;\u0026#34;0\u0026#34;;  sumb --;  }  for(int i=0;i\u0026lt;k;i++)  {  cout\u0026lt;\u0026lt;a[i];  }  }  }  return 0; }   思路分析及问题\n  乙1025   题目描述\n给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。\n输入格式：\n每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 N (≤105)、以及正整数 K (≤N)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。\n接下来有 N 行，每行格式为：\nAddress Data Next\n其中 Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。\n输出格式：\n对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。\n输入样例：\n00100 6 4 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218\n输出样例：\n00000 4 33218 33218 3 12309 12309 2 00100 00100 1 99999 99999 5 68237 68237 6 -1\n  代码\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; //reverse using namespace std; int main() {  int first, k, n, temp;  cin \u0026gt;\u0026gt; first \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; //输入第一个结点的地址，结点个数，翻转个数  int data[100005], next[100005], list[100005];  //分别记录结点的 data , next , 和 address  for (int i = 0; i \u0026lt; n; i++) {  cin \u0026gt;\u0026gt; temp; //结点的address  cin \u0026gt;\u0026gt; data[temp] \u0026gt;\u0026gt; next[temp]; //输入结点的data及next信息  }  int sum = 0;//不一定所有的输入的结点都是有用的，加个计数器  while (first != -1) {  list[sum++] = first; //按链表顺序记录结点的地址  first = next[first]; //将first改为下一个结点的地址  }  for (int i = 0; i \u0026lt; (sum - sum % k); i += k)  reverse(begin(list) + i, begin(list) + i + k);  // reverse(begin,end)逆转元素，begin()返回指向容器最开始位置数据的指针  for (int i = 0; i \u0026lt; sum - 1; i++)  printf(\u0026#34;%05d %d %05d\\n\u0026#34;, list[i], data[list[i]], list[i + 1]);  printf(\u0026#34;%05d %d -1\u0026#34;, list[sum - 1], data[list[sum - 1]]);  return 0; }   思路分析及问题\n  乙1026   题目描述\n要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。\n这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。\n输入格式：\n输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 \u0026lt; C2，并且取值在 [0,107]。\n输出格式：\n在一行中输出被测函数运行的时间。运行时间必须按照 hh:mm:ss（即2位的 时:分:秒）格式输出；不足 1 秒的时间四舍五入到秒。\n输入样例：\n123 4577973\n输出样例：\n12:42:59\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;math.h\u0026gt;using namespace std; const int CLK_TCK=100; int main() {  double C1,C2;  cin\u0026gt;\u0026gt;C1\u0026gt;\u0026gt;C2;  int time=floor((C2-C1)/CLK_TCK+0.5);//floor实现四舍五入  int hour=0,minute=0,second=0;  hour=time/3600; //除以3600，相当于10进制除以100取百位  minute=time/60%60; //类似  second=time%60;  if(hour\u0026lt;10)  cout\u0026lt;\u0026lt;\u0026#34;0\u0026#34;\u0026lt;\u0026lt;hour\u0026lt;\u0026lt;\u0026#34;:\u0026#34;;//按照格式小于10补0  else  cout\u0026lt;\u0026lt;hour\u0026lt;\u0026lt;\u0026#34;:\u0026#34;;  if(minute\u0026lt;10)  cout\u0026lt;\u0026lt;\u0026#34;0\u0026#34;\u0026lt;\u0026lt;minute\u0026lt;\u0026lt;\u0026#34;:\u0026#34;;  else  cout\u0026lt;\u0026lt;minute\u0026lt;\u0026lt;\u0026#34;:\u0026#34;;  if(second\u0026lt;10)  cout\u0026lt;\u0026lt;\u0026#34;0\u0026#34;\u0026lt;\u0026lt;second\u0026lt;\u0026lt;endl;  else  cout\u0026lt;\u0026lt;second\u0026lt;\u0026lt;endl;  return 0; }   思路分析及问题\n  乙1027   题目描述\n本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印\n***** *** * *** *****\n所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。\n给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。\n输入格式:\n输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。\n输出格式:\n首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。\n输入样例:\n19 *\n输出样例:\n***** *** * *** *****\n2\n  代码\n#include \u0026lt;iostream\u0026gt;using namespace std; int main() {  int N, row = 0;  char c;  cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; c;  for (int i = 0; i \u0026lt; N; i++) {  if ((2 * i * (i + 2) + 1) \u0026gt; N) {  row = i - 1;  break;  }  }  for (int i = row; i \u0026gt;= 1; i--) {  for (int k = row - i; k \u0026gt;= 1; k--) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  for (int j = i * 2 + 1; j \u0026gt;= 1; j--) cout \u0026lt;\u0026lt; c;  cout \u0026lt;\u0026lt; endl;  }  for (int i = 0; i \u0026lt; row; i++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl;\t for (int i = 1; i \u0026lt;= row; i++) {  for (int k = row - i; k \u0026gt;= 1; k--) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  for (int j = i * 2 + 1; j \u0026gt;= 1; j--) cout \u0026lt;\u0026lt; c;  cout \u0026lt;\u0026lt; endl;  }  cout \u0026lt;\u0026lt; (N - (2 * row * (row + 2) + 1)); return 0; }   思路分析及问题\n  乙1028  题目描述 代码 思路分析及问题  乙1029  题目描述 代码 思路分析及问题  乙1030  题目描述 代码 思路分析及问题  乙1031   题目描述\n一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：\n首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：\nZ：0 1 2 3 4 5 6 7 8 9 10 M：1 0 X 9 8 7 6 5 4 3 2\n现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。\n输入格式：\n输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。\n输出格式：\n按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。\n输入样例1：\n4 320124198808240056 12010X198901011234 110108196711301866 37070419881216001X\n输出样例1：\n12010X198901011234 110108196711301866 37070419881216001X\n输入样例2：\n2 320124198808240056 110108196711301862\n输出样例2：\nAll passed\n  代码\n#include \u0026lt;iostream\u0026gt;using namespace std; int a[17] = {7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2}; int b[11] = {1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2}; string s; bool isTrue() {  int sum = 0;  for (int i = 0; i \u0026lt; 17; i++) {  if (s[i] \u0026lt; \u0026#39;0\u0026#39; || s[i] \u0026gt; \u0026#39;9\u0026#39;) return false;  sum += (s[i] - \u0026#39;0\u0026#39;) * a[i];  }  int temp = (s[17] == \u0026#39;X\u0026#39;) ? 10 : (s[17] - \u0026#39;0\u0026#39;);  return b[sum%11] == temp; } int main() {  int n, flag = 0;  cin \u0026gt;\u0026gt; n;  for (int i = 0; i \u0026lt; n; i++) {  cin \u0026gt;\u0026gt; s;  if (!isTrue()) {  cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl;  flag = 1;  }  }  if (flag == 0) cout \u0026lt;\u0026lt; \u0026#34;All passed\u0026#34;;  return 0; }   思路分析及问题\n分析：isTrue函数判断身份证号是否正常，如果不正常返回false，判断每一个给出的身份证号，如果不正常，就输出这个身份证号，并且置flag=1表示有不正常的号码，如果所有的号码都是正常，即flag依旧等于0，则输出All passed～在isTrue函数中，先判断前17位是否是数字，如果不是，直接return false，如果是，就将当前字符转化为数字并与a[i]相乘，累加在sum中，对于第18位，如果是X要转化为10～比较b[sum%11]和第18位是否相等，如果相等就返回true，不相等就返回false～\n  乙1032   题目描述\n为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。\n输入格式：\n输入在第 1 行给出不超过 105 的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。\n输出格式：\n在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。\n输入样例：\n6 3 65 2 80 1 100 2 70 3 40 3 0\n输出样例：\n2 150\n  代码\n#include \u0026lt;stdio.h\u0026gt;int school[100000] = { 0 };//题目要求把数组的声明放在第1行 int main() {  int n, sid, score;  scanf(\u0026#34;%d\u0026#34;, \u0026amp;n);  for (int i = 1; i \u0026lt;= n; i++) {  scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;sid, \u0026amp;score);  school[sid] += score;//将id相同的score累加起来,统计总成绩  }  int k = -1, max = -1;  for (int i = 1; i \u0026lt;= n; i++) {//遍历  if (school[i] \u0026gt; max) {//遍历比较  max = school[i];//将最大值赋给max  k = i;//记录下标  }  }  printf(\u0026#34;%d %d\u0026#34;, k, max);  return 0; }   思路分析及问题\n  乙1033  题目描述 代码 思路分析及问题  乙1034   题目描述\n本题要求编写程序，计算 2 个有理数的和、差、积、商。\n输入格式：\n输入在一行中按照 a1/b1 a2/b2 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。\n输出格式：\n分别在 4 行中按照 有理数1 运算符 有理数2 = 结果 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 k a/b，其中 k 是整数部分，a/b 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 Inf。题目保证正确的输出中没有超过整型范围的整数。\n输入样例 1：\n2/3 -4/2\n输出样例 1：\n2/3 + (-2) = (-1 1/3) 2/3 - (-2) = 2 2/3 2/3 * (-2) = (-1 1/3) 2/3 / (-2) = (-1/3)\n输入样例 2：\n5/3 0/6\n输出样例 2：\n1 2/3 + 0 = 1 2/3 1 2/3 - 0 = 1 2/3 1 2/3 * 0 = 0 1 2/3 / 0 = Inf\n  代码\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt; //absusing namespace std; long long a, b, c, d; //全局变量 long long gcd(long long t1, long long t2) { \treturn t2 == 0 ? t1 : gcd(t2, t1 % t2); } void func(long long m, long long n) {  if (m * n == 0) {  printf(\u0026#34;%s\u0026#34;, n == 0 ? \u0026#34;Inf\u0026#34; : \u0026#34;0\u0026#34;);  return ;  }  bool flag = ((m \u0026lt; 0 \u0026amp;\u0026amp; n \u0026gt; 0) || (m \u0026gt; 0 \u0026amp;\u0026amp; n \u0026lt; 0));  m = abs(m); n = abs(n);  long long x = m / n;  printf(\u0026#34;%s\u0026#34;, flag ? \u0026#34;(-\u0026#34; : \u0026#34;\u0026#34;); //异号就输出负号  if (x != 0) printf(\u0026#34;%lld\u0026#34;, x); //整数部分  if (m % n == 0) {  if(flag) printf(\u0026#34;)\u0026#34;);  return ;  }  if (x != 0) printf(\u0026#34; \u0026#34;);  m = m - x * n;  long long t = gcd(m, n);  m = m / t; n = n / t;  printf(\u0026#34;%lld/%lld%s\u0026#34;, m, n, flag ? \u0026#34;)\u0026#34; : \u0026#34;\u0026#34;); } int main() {  scanf(\u0026#34;%lld/%lld %lld/%lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d);  func(a, b); printf(\u0026#34; + \u0026#34;); func(c, d); printf(\u0026#34; = \u0026#34;); func(a * d + b * c, b * d); printf(\u0026#34;\\n\u0026#34;);  func(a, b); printf(\u0026#34; - \u0026#34;); func(c, d); printf(\u0026#34; = \u0026#34;); func(a * d - b * c, b * d); printf(\u0026#34;\\n\u0026#34;);  func(a, b); printf(\u0026#34; * \u0026#34;); func(c, d); printf(\u0026#34; = \u0026#34;); func(a * c, b * d); printf(\u0026#34;\\n\u0026#34;);  func(a, b); printf(\u0026#34; / \u0026#34;); func(c, d); printf(\u0026#34; = \u0026#34;); func(a * d, b * c);  return 0; }   思路分析及问题\n分析：func(m, n)的作用是对m/n的分数进行化简，gcd(t1, t2)的作用是计算t1和t2的最大公约数～在func函数中，先看m和n里面是否有0（即m*n是否等于0），如果分母n=0，输出Inf，如果分子m=0，输出\u0026quot;0\u0026quot;～flag表示m和n是否异号，flag=true表示后面要添加负号\u0026quot;(-\u0026ldquo;和括号\u0026rdquo;)\u0026quot;，再将m和n都转为abs(m)和abs(n)，即取他们的正数部分方便计算～x = m/n为m和n的可提取的整数部分，先根据flag的结果判断是否要在前面追加\u0026quot;(-\u0026quot;，然后根据x是否等于0判断要不要输出这个整数位，接着根据m%n是否等于0的结果判断后面还有没有小分数，如果m能被n整除，表示没有后面的小分数，那么就根据flag的结果判断要不要加\u0026quot;)\u0026quot;，然后直接return～如果有整数位，且后面有小分数，则要先输出一个空格，接着处理剩下的小分数，先把m分子减去已经提取出的整数部分，然后求m和n的最大公约数t，让m和n都除以t进行化简～最后输出“m/n”，如果flag==true还要在末尾输出\u0026quot;)\u0026quot;，关键在于化简\n  乙1035   题目描述\n根据维基百科的定义：\n插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。\n归并排序进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。\n现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？\n输入格式：\n输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。\n输出格式：\n首先在第 1 行中输出Insertion Sort表示插入排序、或Merge Sort表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。\n输入样例 1：\n10 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0\n输出样例 1：\nInsertion Sort 1 2 3 5 7 8 9 4 6 0\n输入样例 2：\n10 3 1 2 8 7 5 9 4 0 6 1 3 2 8 5 7 4 9 0 6\n输出样例 2：\nMerge Sort 1 2 3 8 4 5 7 9 0 6\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;algorithm\u0026gt;using namespace std; int n; void insort(int a[], int b[]) {  int key = 0; //当匹配到中间序列时，key置1，下次排序后输出，结束程序就行  for (int i = 2; i \u0026lt;= n; i++) { //插入排序起始为2，结束为n，否则测试点2不通过  sort(a, a + i);  if (key) {  cout \u0026lt;\u0026lt; \u0026#34;Insertion Sort\u0026#34; \u0026lt;\u0026lt; endl;  cout \u0026lt;\u0026lt; a[0];  for (int j = 1; j \u0026lt; n; j++)  cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[j];  return;  }  if (equal(a, a + n, b)) //equal是一个比较数组的函数,测试是否在两个范围的元素都是平等的  key = 1;  }//3个参数first1,last1和first2.如果对于区间[first1,last1)内所有的first1+i,first1+i和first2所在位置处的元素都相等，则equal算法返回真，否则返回假。 } void mesort(int a[], int b[]) {  int key = 0;  for (int i = 2;; i *= 2) { //这里不给结束条件，是因为当i\u0026gt;n时还要进行一次排序  for (int j = 0; j \u0026lt; n; j += i) {  sort(a + j, a + (j + i \u0026lt; n ? j + i : n)); //注意确定边界  }  if (key) {  cout \u0026lt;\u0026lt; \u0026#34;Merge Sort\u0026#34; \u0026lt;\u0026lt; endl;  cout \u0026lt;\u0026lt; a[0];  for (int j = 1; j \u0026lt; n; j++)  cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[j];  return;  }  if (equal(a, a + n, b))  key = 1;  if (i \u0026gt; n)  break;  } } int main() {  cin \u0026gt;\u0026gt; n;  int a1[100], a2[100], b[100];  for (int i = 0; i \u0026lt; n; i++) {  cin \u0026gt;\u0026gt; a1[i];//输入原始序列  a2[i] = a1[i];  }  for (int i = 0; i \u0026lt; n; i++)  cin \u0026gt;\u0026gt; b[i];//输入中间数列  insort(a2, b);//表示插入排序  mesort(a1, b);//表示归并排序  return 0; }   思路分析及问题\n  乙1036   题目描述\n美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ 输入格式： 输入在一行中给出正方形边长 N（3≤N≤20）和组成正方形边的某种字符 C，间隔一个空格。 输出格式： 输出由给定字符 C 画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。 输入样例： 10 a 输出样例： aaaaaaaaaa a a a a a a aaaaaaaaaa   代码\n#include\u0026lt;cstdio\u0026gt;int main(){  int row,col;//行，列  char c;  scanf(\u0026#34;%d %c\u0026#34;,\u0026amp;col,\u0026amp;c);//输入列数，欲使用的字符  if(col%2==1) row=col/2+1; //col为奇数,向上取整  else row=col/2; //col为偶数  //第1行  for(int i=0;i\u0026lt;col;i++){  printf(\u0026#34;%c\u0026#34;,c); //col个字符  }  printf(\u0026#34;\\n\u0026#34;);  //第2~row-1行  for(int i=2;i\u0026lt;row;i++){  printf(\u0026#34;%c\u0026#34;,c);//每行的第一个a  for(int j=0;j\u0026lt;col-2;j++)  printf(\u0026#34; \u0026#34;); //col-2个空格  printf(\u0026#34;%c\\n\u0026#34;,c);//每行最后一个a  }  //第row行  for(int i=0;i\u0026lt;col;i++)  printf(\u0026#34;%c\u0026#34;,c); //col个字符  return 0; }   思路分析及问题\n  乙1037   题目描述\n如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱 P 和他实付的钱 A，你的任务是写一个程序来计算他应该被找的零钱。\n输入格式：\n输入在 1 行中分别给出 P 和 A，格式为 Galleon.Sickle.Knut，其间用 1 个空格分隔。这里 Galleon 是 [0, 107] 区间内的整数，Sickle 是 [0, 17) 区间内的整数，Knut 是 [0, 29) 区间内的整数。\n输出格式：\n在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。\n输入样例 1：\n10.16.27 14.1.28\n输出样例 1：\n3.2.1\n输入样例 2：\n14.1.28 10.16.27\n输出样例 2：\n-3.2.1\n  代码\n#include \u0026lt;iostream\u0026gt;using namespace std;  int main() {  int a, b ,c, m, n, t, x, y, z;  scanf(\u0026#34;%d.%d.%d %d.%d.%d\u0026#34;,\u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;m, \u0026amp;n, \u0026amp;t);  if (a \u0026gt; m || (a == m \u0026amp;\u0026amp; b \u0026gt; n) || (a == m \u0026amp;\u0026amp; b == n \u0026amp;\u0026amp; c \u0026gt; t)) {  swap(a, m); swap(b, n); swap(c, t);  printf(\u0026#34;-\u0026#34;);  }  z = t \u0026lt; c ? t - c + 29 : t - c;  n = t \u0026lt; c ? n - 1 : n;  y = n \u0026lt; b ? n - b + 17 : n - b;  x = n \u0026lt; b ? m - a - 1 : m - a;  printf(\u0026#34;%d.%d.%d\u0026#34;, x, y, z);  return 0; }   思路分析及问题\n**分析：abc代表应付的钱，mnt代表实付的钱，首先判断应付的钱是否大于实付的钱，如果大于，说明钱不够，为了简化计算，将a和m、b和n、c和t调换，使得计算(mnt-abc)时是大的减去小的～调换之后别忘记输出负号～xyz分别代表找的钱，从低位向高位计算，如果t \u0026lt; c，说明要向前借位，借一位后自己加上29，否则z = t – c即可～别忘记如果有借位，n要减去1～然后计算中间位，如果n \u0026lt; b，说明要借位，则y = n – b + 17，否则不用借位，y = n – b即可～最后计算最高位x，**如果n \u0026lt; b引起了借位，则x = m – a – 1，否则x = m – a即可～最后输出x.y.z～\n  乙1038   题目描述\n本题要求读入 N 名学生的成绩，将获得某一给定分数的学生人数输出。\n输入格式：\n输入在第 1 行给出不超过 105 的正整数 N，即学生总人数。随后一行给出 N 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 K（不超过 N 的正整数），随后是 K 个分数，中间以空格分隔。\n输出格式：\n在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。\n输入样例：\n10 60 75 90 55 75 99 82 90 75 50 3 75 90 88\n输出样例：\n3 2 0\n  代码\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; int main() {  int n, m, temp;  scanf(\u0026#34;%d\u0026#34;, \u0026amp;n);  vector\u0026lt;int\u0026gt; b(101); //最高分不会超过101  for (int i = 0; i \u0026lt; n; i++) {  scanf(\u0026#34;%d\u0026#34;, \u0026amp;temp);  b[temp]++;  }  scanf(\u0026#34;%d\u0026#34;, \u0026amp;m);  for (int i = 0; i \u0026lt; m; i++) {  scanf(\u0026#34;%d\u0026#34;, \u0026amp;temp);  if (i != 0) printf(\u0026#34; \u0026#34;);  printf(\u0026#34;%d\u0026#34;, b[temp]);  }  return 0; }   思路分析及问题\n分析：用b数组保存每个分数对应的学生人数，在输入的时候，对于每一个成绩temp，b[temp]++表示将数组b中对应分数的人数+1～对于m个查询，每一次都输出需要查询的temp所对应的人数b[temp]，注意i不等于0的时候要在输出人数之前输出一个空格～\n  乙1039   题目描述\n  代码\n  思路分析及问题\n  乙1040   题目描述\n字符串 APPAPT 中包含了两个单词 PAT，其中第一个 PAT 是第 2 位(P)，第 4 位(A)，第 6 位(T)；第二个 PAT 是第 3 位(P)，第 4 位(A)，第 6 位(T)。\n现给定字符串，问一共可以形成多少个 PAT？\n输入格式：\n输入只有一行，包含一个字符串，长度不超过105，只包含 P、A、T 三种字母。\n输出格式：\n在一行中输出给定字符串中包含多少个 PAT。由于结果可能比较大，只输出对 1000000007 取余数的结果。\n输入样例：\nAPPAPT\n输出样例：\n2\n作者: CAO, Peng\n单位: Google\n时间限制: 150 ms\n内存限制: 64 MB\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;using namespace std; int main() {  int num_p=0,num=0;  long sum = 0;  string str;  getline(cin, str);  int length = str.length();  for (int i = 0; i \u0026lt; length; ++i)  {  if (str[i] == \u0026#39;P\u0026#39;)  ++num_p; //统计A前面的P的个数  else if (str[i] == \u0026#39;A\u0026#39;)  num += num_p; //num统计固定的T前面所有的A前面P的个数相加  else if (str[i] == \u0026#39;T\u0026#39;)  sum+=num; //统计每个T所存在的PAT总数  }  cout \u0026lt;\u0026lt; sum % 1000000007 \u0026lt;\u0026lt; endl; }   思路分析及问题\n本题思路比较清晰，先寻找第一个T前面的A的个数，再统计每个A前面P的个数，最后统计起来，\n注意：能满足前面T形成PAT的P和A也一定满足该T后面所有T形成PAT\n  乙1041  题目描述 代码 思路分析及问题  乙1042   题目描述\n请编写程序，找出一段给定文字中出现最频繁的那个英文字母。\n输入格式：\n输入在一行中给出一个长度不超过 1000 的字符串。字符串由 ASCII 码表中任意可见字符及空格组成，至少包含 1 个英文字母，以回车结束（回车不算在内）。\n输出格式：\n在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。\n输入样例：\nThis is a simple TEST. There ARE numbers and other symbols 1\u0026amp;2\u0026amp;3\u0026hellip;\u0026hellip;\u0026hellip;..\n输出样例：\ne 7\n  代码\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt;int hashTable[128] = {0}; int main(){  char str[1010];  scanf(\u0026#34;%[^\\n]\u0026#34;,str); //以\\n标识结束符(读取空格)  //gets(str);  int len = strlen(str);  for(int i = 0; i \u0026lt; len; i++){  if(str[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; str[i] \u0026lt;= \u0026#39;Z\u0026#39;){  str[i] += 32; //大写字母转为小写  }  int id = str[i]; //id就设为小写字母的ascii码 (ascii码的顺序和字母序一样)  hashTable[id]++;  }  int max = 0;  int k;  for(int i = 96; i \u0026lt; 122; i++){ \t// a:96,z:122  if(hashTable[i] \u0026gt; max){  max = hashTable[i];  k = i;  }  }  printf(\u0026#34;%c %d\\n\u0026#34;, k, hashTable[k]);  return 0; }   思路分析及问题\n  乙1043   题目描述\n给定一个长度不超过 104 的、仅由英文字母构成的字符串。请将字符重新调整顺序，按 PATestPATest\u0026hellip;. 这样的顺序输出，并忽略其它字符。当然，六种字符的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按 PATest 的顺序打印，直到所有字符都被输出。\n输入格式：\n输入在一行中给出一个长度不超过 104 的、仅由英文字母构成的非空字符串。\n输出格式：\n在一行中按题目要求输出排序后的字符串。题目保证输出非空。\n输入样例：\nredlesPayBestPATTopTeePHPereatitAPPT\n输出样例：\nPATestPATestPTetPTePePee\n  代码\n#include \u0026lt;iostream\u0026gt;using namespace std; int main() {  int map[128] = {0}, c;  while ((c = cin.get()) != EOF) map[c]++;  //数组的索引为对应的字符(数组的索引为字符串类型)  while (map[\u0026#39;P\u0026#39;] \u0026gt; 0 || map[\u0026#39;A\u0026#39;] \u0026gt; 0 || map[\u0026#39;T\u0026#39;] \u0026gt; 0 || map[\u0026#39;e\u0026#39;] \u0026gt; 0 || map[\u0026#39;s\u0026#39;] \u0026gt; 0 || map[\u0026#39;t\u0026#39;] \u0026gt; 0) {  if (map[\u0026#39;P\u0026#39;]-- \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#39;P\u0026#39;; //每输出一个之后减1  if (map[\u0026#39;A\u0026#39;]-- \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#39;A\u0026#39;;  if (map[\u0026#39;T\u0026#39;]-- \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#39;T\u0026#39;;  if (map[\u0026#39;e\u0026#39;]-- \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#39;e\u0026#39;;  if (map[\u0026#39;s\u0026#39;]-- \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#39;s\u0026#39;;  if (map[\u0026#39;t\u0026#39;]-- \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#39;t\u0026#39;;  }  return 0; }   思路分析及问题\n分析：将字符串的每一个字符出现的个数保存在int map[128]中，然后依次输出PATest，每次输出一次字符就将map对应的字符个数减1～\n  乙1044   题目描述\n火星人是以 13 进制计数的：\n 地球人的 0 被火星人称为 tret。 地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。 火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。  例如地球人的数字 29 翻译成火星文就是 hel mar；而火星文 elo nov 对应地球数字 115。为了方便交流，请你编写程序实现地球和火星数字之间的互译。\n输入格式：\n输入第一行给出一个正整数 N（\u0026lt;100），随后 N 行，每行给出一个 [0, 169) 区间内的数字 —— 或者是地球文，或者是火星文。\n输出格式：\n对应输入的每一行，在一行中输出翻译后的另一种语言的数字。\n输入样例：\n4 29 5 elo nov tam\n输出样例：\nhel mar may 115 13\n  代码\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cctype\u0026gt; //isdigit#include \u0026lt;string\u0026gt;using namespace std; const string low[] = { \u0026#34;tret\u0026#34;,\u0026#34;jan\u0026#34;, \u0026#34;feb\u0026#34;, \u0026#34;mar\u0026#34;, \u0026#34;apr\u0026#34;, \u0026#34;may\u0026#34;, \u0026#34;jun\u0026#34;, \u0026#34;jly\u0026#34;, \u0026#34;aug\u0026#34;, \u0026#34;sep\u0026#34;, \u0026#34;oct\u0026#34;, \u0026#34;nov\u0026#34;, \u0026#34;dec\u0026#34; }; const string high[] = { \u0026#34;\u0026#34;, \u0026#34;tam\u0026#34;, \u0026#34;hel\u0026#34;, \u0026#34;maa\u0026#34;, \u0026#34;huh\u0026#34;, \u0026#34;tou\u0026#34;, \u0026#34;kes\u0026#34;, \u0026#34;hei\u0026#34;, \u0026#34;elo\u0026#34;, \u0026#34;syy\u0026#34;, \u0026#34;lok\u0026#34;, \u0026#34;mer\u0026#34;, \u0026#34;jou\u0026#34; }; int MarsToEarth(string s) {  int h = 0;  int l = 0;  string hs;  string ls;  if (s.length() \u0026gt; 4) {  hs = s.substr(0, 3);  ls = s.substr(4, 3);  }  else {  hs = s;  ls = s;  }  for (int i = 0; i \u0026lt; 13; i++) {  if (high[i] == hs) {  h = i * 13;  break;  }  }  for (int i = 0; i \u0026lt; 13; i++) {  if (low[i] == ls) {  l = i;  break;  }  }  return h + l; } string EarthToMars(int i) {  string h = high[i / 13];  string l = low[i % 13];  if (h != \u0026#34;\u0026#34;) {  if (l == \u0026#34;tret\u0026#34;) {  l = \u0026#34;\u0026#34;;  }  else {  h += \u0026#34; \u0026#34;;  }  }  return h + l; } int main() {  int n;  cin \u0026gt;\u0026gt; n;  getchar();//吸收回车符  string s;  for (int i = 0; i \u0026lt; n; i++) {  getline(cin, s);//读取整行  if (isdigit(s[0])) {  cout \u0026lt;\u0026lt; EarthToMars(stoi(s)) \u0026lt;\u0026lt; endl;  }  else {  cout \u0026lt;\u0026lt; MarsToEarth(s) \u0026lt;\u0026lt; endl;  }  }  return 0; }   思路分析及问题\n思路\n首先判断是地球文还是火星文，根据第一个字符是否为数字确定。\n然后分别转换，注意“tret”四个字符与众不同。\n注意：\n读入数据时，一行中可能出现空格时，需要用\ngetline(cin, s)\ncin \u0026raquo; s 只能读到空格前一个单词。\ngetline前有回车时（如本题中前面有cin\u0026raquo;n，后跟了回车），需要加一个getchar()吸收回车\n  乙1045   题目描述\n著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？\n例如给定 $N = 5$, 排列是1、3、2、4、5。则：\n 1 的左边没有元素，右边的元素都比它大，所以它可能是主元； 尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元； 尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元； 类似原因，4 和 5 都可能是主元。  因此，有 3 个元素可能是主元。\n输入格式：\n输入在第 1 行中给出一个正整数 N（≤105）； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 109。\n输出格式：\n在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。\n输入样例：\n5 1 3 2 4 5\n输出样例：\n3 1 4 5\n  代码\n#include\u0026lt;cstdio\u0026gt;#include\u0026lt;malloc.h\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;algorithm\u0026gt;using namespace std; int main() {  int n;  scanf(\u0026#34;%d\u0026#34;, \u0026amp;n);  int *a;  a = (int*)malloc(n);//动态分配内存  for (int i = 0; i \u0026lt; n; i++)  {  scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]);  }  vector\u0026lt;int\u0026gt; pivots;  for (int i = 0; i \u0026lt; n; i++)  {  //遍历每一个元素  int flag = 0;//0表示可能为主元  for (int j = 0; j \u0026lt; i; j++)  {  //左边的  if (a[j] \u0026gt; a[i])  {  flag = 1;  break;  }  }  for (int j = i + 1; j \u0026lt; n; j++)  {  //右边的  if (a[j] \u0026lt; a[i])  {  flag = 1;  break;  }  }  if (flag==0)  {  pivots.push_back(a[i]);  }  }  sort(pivots.begin(), pivots.end());  printf(\u0026#34;%d\\n\u0026#34;, pivots.size());  for (size_t i = 0; i \u0026lt; pivots.size(); i++)  {  printf(\u0026#34;%d\u0026#34;, pivots[i]);  if (i\u0026lt;pivots.size()-1)  {  printf(\u0026#34; \u0026#34;);  }  }  return 0; }   思路分析及问题\n  乙1046  题目描述 代码 思路分析及问题  乙1047   题目描述\n编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。\n现给定所有队员的比赛成绩，请你编写程序找出冠军队。\n输入格式：\n输入第一行给出一个正整数 N（≤104），即所有参赛队员总数。随后 N 行，每行给出一位队员的成绩，格式为：队伍编号-队员编号 成绩，其中队伍编号为 1 到 1000 的正整数，队员编号为 1 到 10 的正整数，成绩为 0 到 100 的整数。\n输出格式：\n在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。\n输入样例：\n6 3-10 99 11-5 87 102-1 0 102-3 100 11-9 89 3-2 61\n输出样例：\n11 176\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;using namespace std; int main() {  int n;  cin \u0026gt;\u0026gt; n;  getchar();//回车符  int teamScore[1001] = { 0 };//记录每个队伍的总分  string str;  for (int i = 0; i \u0026lt; n; i++)  {  getline(cin, str);  int team = stoi(str.substr(0, str.find(\u0026#39;-\u0026#39;) - 0));//提取队伍编号  int score = stoi(str.substr(str.find(\u0026#39; \u0026#39;) + 1, str.find(\u0026#39;\\0\u0026#39;) - str.find(\u0026#39; \u0026#39;) - 1));//提取该队员的分数  teamScore[team] += score;  }  int max=0, k=0;  for (int i = 0; i \u0026lt; 1001; i++)  {  if (teamScore[i] \u0026gt; max)  {  max = teamScore[i];  k = i;  }  }  cout \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; max;  return 0; }   思路分析及问题\n  乙1048   题目描述\n本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。\n输入格式：\n输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。\n输出格式：\n在一行中输出加密后的结果。\n输入样例：\n1234567 368782971\n输出样例：\n3695Q8118\n  代码\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;algorithm\u0026gt; //reverseusing namespace std; int main() {  string A, B, result;  cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B;  //反转a,b使得个位在前  reverse(A.begin(), A.end());  reverse(B.begin(), B.end());  //短的后面补0  if (A.length() \u0026lt; B.length())  A += string(B.length() - A.length(), \u0026#39;0\u0026#39;);  else if (A.length() \u0026gt; B.length())  B += string(A.length() - B.length(), \u0026#39;0\u0026#39;);  int len = B.length();  for (int i = 0; i != len; i++) {  if (i % 2 == 0) {  int temp = (A[i] + B[i] - \u0026#39;0\u0026#39; - \u0026#39;0\u0026#39;) % 13;  if (temp == 10) result += \u0026#39;J\u0026#39;;  else if (temp == 11) result += \u0026#39;Q\u0026#39;;  else if (temp == 12) result += \u0026#39;K\u0026#39;;  else result += temp + \u0026#39;0\u0026#39;;  }  else  result += (B[i] - A[i] + 10) % 10 + \u0026#39;0\u0026#39;;  }  reverse(result.begin(), result.end()); //最后再反转回去  cout \u0026lt;\u0026lt; result; }   思路分析及问题\n  乙1049   题目描述\n给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段。\n给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。\n输入格式：\n输入第一行给出一个不超过 105 的正整数 N，表示数列中数的个数，第二行给出 N 个不超过 1.0 的正数，是数列中的数，其间以空格分隔。\n输出格式：\n在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。\n输入样例：\n4 0.1 0.2 0.3 0.4\n输出样例：\n5.00\n  代码\n#include \u0026lt;iostream\u0026gt;using namespace std; int main() {  int n;  cin \u0026gt;\u0026gt; n;  double sum = 0.0, temp;  for (int i = 1; i \u0026lt;= n; i++) {  cin \u0026gt;\u0026gt; temp;  sum = sum + temp * i * (n - i + 1);  }  printf(\u0026#34;%.2f\u0026#34;, sum);  return 0; }   思路分析及问题\n分析：将数列中的每个数字读取到temp中，假设我们选取的片段中包括temp，且这个片段的首尾指针分别为p和q，那么对于p，有i种选择，即12…i，对于q，有n-i+1种选择，即i, i+1, … n，所以p和q组合形成的首尾片段有i * (n-i+1)种，因为每个里面都会出现temp，所以temp引起的总和为temp * i * (n – i + 1)；遍历完所有数字，将每个temp引起的总和都累加到sum中，最后输出sum的值～\n  乙1050   题目描述\n本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。\n输入格式：\n输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 104，相邻数字以空格分隔。\n输出格式：\n输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。\n输入样例：\n12 37 76 20 98 76 42 53 95 60 81 58 93\n输出样例：\n98 95 93 42 37 81 53 20 76 58 60 76\n  代码\n #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; int cmp(int a, int b) {return a \u0026gt; b;} int main() {  int N, m, n, t = 0;  scanf(\u0026#34;%d\u0026#34;, \u0026amp;N);  for (n = sqrt((double)N); n \u0026gt;= 1; n--) {  if (N % n == 0) {  m = N / n;  break;  }  }  vector\u0026lt;int\u0026gt; a(N);  for (int i = 0; i \u0026lt; N; i++)  scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]);  sort(a.begin(), a.end(), cmp);  vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; b(m, vector\u0026lt;int\u0026gt;(n));  int level = m / 2 + m % 2;  for (int i = 0; i \u0026lt; level; i++) {  for (int j = i; j \u0026lt;= n - 1 - i \u0026amp;\u0026amp; t \u0026lt;= N - 1; j++)  b[i][j] = a[t++];  for (int j = i + 1; j \u0026lt;= m - 2 - i \u0026amp;\u0026amp; t \u0026lt;= N - 1; j++)  b[j][n - 1 - i] = a[t++];  for (int j = n - i - 1; j \u0026gt;= i \u0026amp;\u0026amp; t \u0026lt;= N - 1; j--)  b[m - 1 - i][j] = a[t++];  for (int j = m - 2 - i; j \u0026gt;= i + 1 \u0026amp;\u0026amp; t \u0026lt;= N - 1; j--)  b[j][i] = a[t++];  }  for (int i = 0; i \u0026lt; m; i++) {  for (int j = 0 ; j \u0026lt; n; j++) {  printf(\u0026#34;%d\u0026#34;, b[i][j]);  if (j != n - 1) printf(\u0026#34; \u0026#34;);  }  printf(\u0026#34;\\n\u0026#34;);  }  return 0; }   思路分析及问题\n分析：首先计算行数m和列数n的值，n从根号N的整数部分开始，往前推一直到1，找到第一个满足N % n== 0的，m的值等于N/n～将N个给定的值输入数组a，并将a数组中的值按非递增排序，接着建立m行n列的数组b，填充时按层数填充，一个包裹矩阵的口字型为一层，计算螺旋矩阵的层数level，如果m的值为偶数，层数为m/2，如果m为奇数，层数为m/2+1，所以level = m / 2 + m % 2；因为是从左上角第1个格子开始，按顺时针螺旋方向填充，所以外层for循环控制层数i从0到level，内层for循环按左上到右上、右上到右下、右下到左下、左下到左上的顺序一层层填充，注意内层for循环中还要控制t \u0026lt;= N – 1，因为如果螺旋矩阵中所有的元素已经都填充完毕，就不能再重复填充～填充完毕后，输出整个矩阵～\n  乙1051   题目描述\n复数可以写成 (A+Bi) 的常规形式，其中 A 是实部，B 是虚部，i 是虚数单位，满足 i2=−1；也可以写成极坐标下的指数形式 (R×e(Pi))，其中 R 是复数模，P 是辐角，i 是虚数单位，其等价于三角形式 R(cos(P)+isin(P))。\n现给定两个复数的 R 和 P，要求输出两数乘积的常规形式。\n输入格式：\n输入在一行中依次给出两个复数的 R1, P1, R2, P2，数字间以空格分隔。\n输出格式：\n在一行中按照 A+Bi 的格式输出两数乘积的常规形式，实部和虚部均保留 2 位小数。注意：如果 B 是负数，则应该写成 A-|B|i 的形式。\n输入样例：\n2.3 3.5 5.2 0.4\n输出样例：\n-8.68-8.23i\n  代码\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;math.h\u0026gt;int main() {  double R1, P1, R2, P2, a, b;  int check_a = 1, check_b = 2;  scanf(\u0026#34;%lf %lf %lf %lf\u0026#34;, \u0026amp;R1, \u0026amp;P1, \u0026amp;R2, \u0026amp;P2);  a = R1 * R2 * cos(P1 + P2);  b = R1 * R2 * sin(P1 + P2); // 计算常规形式的两个系数a和b  if (fabs(a) \u0026lt; 0.01) check_a = 0;  if (fabs(b) \u0026lt; 0.01) check_b = 0; // 检查a和b是否为0  if (check_a == 0 \u0026amp;\u0026amp; check_b == 0) // a和b同时为0的情况，只输出一个0  printf(\u0026#34;0\u0026#34;);  else if (check_a == 0 \u0026amp;\u0026amp; check_b != 0) // 其余情况实部和虚部均要输出保留两位小数的数字，包括0  printf(\u0026#34;0.00%+.2fi\u0026#34;, b);  else if (check_a != 0 \u0026amp;\u0026amp; check_b == 0)  printf(\u0026#34;%.2f+0.00i\u0026#34;, a);  else  printf(\u0026#34;%.2f%+.2fi\u0026#34;,a, b);  return 0; }   思路分析及问题\n  乙1052  题目描述 代码 思路分析及问题  乙1053  题目描述 代码 思路分析及问题  乙1054  题目描述 代码 思路分析及问题  乙1055  题目描述 代码 思路分析及问题  乙1056  题目描述 代码 思路分析及问题  乙1057  题目描述 代码 思路分析及问题  乙1058  题目描述 代码 思路分析及问题  乙1059  题目描述 代码 思路分析及问题  乙1060  题目描述 代码 思路分析及问题  乙1061  题目描述 代码 思路分析及问题  乙1062  题目描述 代码 思路分析及问题  乙1063  题目描述 代码 思路分析及问题  乙1064  题目描述 代码 思路分析及问题  乙1065  题目描述 代码 思路分析及问题  乙1066  题目描述 代码 思路分析及问题  乙1067  题目描述 代码 思路分析及问题  乙1068  题目描述 代码 思路分析及问题  乙1069  题目描述 代码 思路分析及问题  乙1070  题目描述 代码 思路分析及问题  乙1071  题目描述 代码 思路分析及问题  乙1072  题目描述 代码 思路分析及问题  乙1073  题目描述 代码 思路分析及问题  乙1074  题目描述 代码 思路分析及问题  乙1075  题目描述 代码 思路分析及问题  乙1076  题目描述 代码 思路分析及问题  乙1077  题目描述 代码 思路分析及问题  乙1078  题目描述 代码 思路分析及问题  乙1079  题目描述 代码 思路分析及问题  乙1080  题目描述 代码 思路分析及问题  乙1081  题目描述 代码 思路分析及问题  乙1082  题目描述 代码 思路分析及问题  乙1083  题目描述 代码 思路分析及问题  乙1084  题目描述 代码 思路分析及问题  乙1085  题目描述 代码 思路分析及问题  乙1086  题目描述 代码 思路分析及问题  乙1087  题目描述 代码 思路分析及问题  乙1088  题目描述 代码 思路分析及问题  乙1089  题目描述 代码 思路分析及问题  乙1090  题目描述 代码 思路分析及问题  乙1091  题目描述 代码 思路分析及问题  乙1092  题目描述 代码 思路分析及问题  乙1093  题目描述 代码 思路分析及问题  乙1094  题目描述 代码 思路分析及问题  乙1095  题目描述 代码 思路分析及问题  甲1001 A+B Format   题目描述\n  代码\n  思路分析及问题\n  甲1002  题目描述 代码 思路分析及问题  甲1003  题目描述 代码 思路分析及问题  甲1004  题目描述 代码 思路分析及问题  甲1005  题目描述 代码 思路分析及问题  甲1006  题目描述 代码 思路分析及问题  甲1007  题目描述 代码 思路分析及问题  甲1008  题目描述 代码 思路分析及问题  甲1009  题目描述 代码 思路分析及问题  甲1010  题目描述 代码 思路分析及问题  甲1011  题目描述 代码 思路分析及问题  甲1012  题目描述 代码 思路分析及问题  甲1013  题目描述 代码 思路分析及问题  甲1014  题目描述 代码 思路分析及问题  甲1015  题目描述 代码 思路分析及问题  甲1016  题目描述 代码 思路分析及问题  甲1017  题目描述 代码 思路分析及问题  甲1018  题目描述 代码 思路分析及问题  甲1019  题目描述 代码 思路分析及问题  甲1020  题目描述 代码 思路分析及问题  甲1021  题目描述 代码 思路分析及问题  甲1022  题目描述 代码 思路分析及问题  甲1023  题目描述 代码 思路分析及问题  甲1024  题目描述 代码 思路分析及问题  甲1025  题目描述 代码 思路分析及问题  甲1026  题目描述 代码 思路分析及问题  甲1027  题目描述 代码 思路分析及问题  甲1028  题目描述 代码 思路分析及问题  甲1029  题目描述 代码 思路分析及问题  甲1030  题目描述 代码 思路分析及问题  甲1031  题目描述 代码 思路分析及问题  甲1032  题目描述 代码 思路分析及问题  甲1033  题目描述 代码 思路分析及问题  甲1034  题目描述 代码 思路分析及问题  甲1035  题目描述 代码 思路分析及问题  甲1036  题目描述 代码 思路分析及问题  甲1037  题目描述 代码 思路分析及问题  甲1038  题目描述 代码 思路分析及问题  甲1039  题目描述 代码 思路分析及问题  甲1040  题目描述 代码 思路分析及问题  甲1041  题目描述 代码 思路分析及问题  甲1042  题目描述 代码 思路分析及问题  甲1043  题目描述 代码 思路分析及问题  甲1044  题目描述 代码 思路分析及问题  甲1045  题目描述 代码 思路分析及问题  甲1046  题目描述 代码 思路分析及问题  甲1047  题目描述 代码 思路分析及问题  甲1048  题目描述 代码 思路分析及问题  甲1049  题目描述 代码 思路分析及问题  甲1050  题目描述 代码 思路分析及问题  甲1051  题目描述 代码 思路分析及问题  甲1052  题目描述 代码 思路分析及问题  甲1053  题目描述 代码 思路分析及问题  甲1054  题目描述 代码 思路分析及问题  甲1055  题目描述 代码 思路分析及问题  甲1056  题目描述 代码 思路分析及问题  甲1057  题目描述 代码 思路分析及问题  甲1058  题目描述 代码 思路分析及问题  甲1059  题目描述 代码 思路分析及问题  甲1060  题目描述 代码 思路分析及问题  甲1061  题目描述 代码 思路分析及问题  甲1062  题目描述 代码 思路分析及问题  甲1063  题目描述 代码 思路分析及问题  甲1064  题目描述 代码 思路分析及问题  甲1065  题目描述 代码 思路分析及问题  甲1066  题目描述 代码 思路分析及问题  甲1067  题目描述 代码 思路分析及问题  甲1068  题目描述 代码 思路分析及问题  甲1069  题目描述 代码 思路分析及问题  甲1070  题目描述 代码 思路分析及问题  甲1071  题目描述 代码 思路分析及问题  甲1072  题目描述 代码 思路分析及问题  甲1073  题目描述 代码 思路分析及问题  甲1074  题目描述 代码 思路分析及问题  甲1075  题目描述 代码 思路分析及问题  甲1076  题目描述 代码 思路分析及问题  甲1077  题目描述 代码 思路分析及问题  甲1078  题目描述 代码 思路分析及问题  甲1079  题目描述 代码 思路分析及问题  甲1080  题目描述 代码 思路分析及问题  甲1081  题目描述 代码 思路分析及问题  甲1082  题目描述 代码 思路分析及问题  甲1083  题目描述 代码 思路分析及问题  甲1084  题目描述 代码 思路分析及问题  甲1085  题目描述 代码 思路分析及问题  甲1086  题目描述 代码 思路分析及问题  甲1087  题目描述 代码 思路分析及问题  甲1088  题目描述 代码 思路分析及问题  甲1089  题目描述 代码 思路分析及问题  甲1090  题目描述 代码 思路分析及问题  甲1091  题目描述 代码 思路分析及问题  甲1092  题目描述 代码 思路分析及问题  甲1093  题目描述 代码 思路分析及问题  甲1094  题目描述 代码 思路分析及问题  甲1095  题目描述 代码 思路分析及问题  甲1096  题目描述 代码 思路分析及问题  甲1097  题目描述 代码 思路分析及问题  甲1098  题目描述 代码 思路分析及问题  甲1099  题目描述 代码 思路分析及问题  甲1100  题目描述 代码 思路分析及问题  甲1101  题目描述 代码 思路分析及问题  甲1102  题目描述 代码 思路分析及问题  甲1103  题目描述 代码 思路分析及问题  甲1104  题目描述 代码 思路分析及问题  甲1105  题目描述 代码 思路分析及问题  甲1106  题目描述 代码 思路分析及问题  甲1107  题目描述 代码 思路分析及问题  甲1108  题目描述 代码 思路分析及问题  甲1109  题目描述 代码 思路分析及问题  甲1110  题目描述 代码 思路分析及问题  甲1095  题目描述 代码 思路分析及问题  甲1111  题目描述 代码 思路分析及问题  甲1112  题目描述 代码 思路分析及问题  甲1113  题目描述 代码 思路分析及问题  甲1114  题目描述 代码 思路分析及问题  甲1115  题目描述 代码 思路分析及问题  甲1116  题目描述 代码 思路分析及问题  甲1117  题目描述 代码 思路分析及问题  甲1118  题目描述 代码 思路分析及问题  甲1119  题目描述 代码 思路分析及问题  甲1120  题目描述 代码 思路分析及问题  甲1121  题目描述 代码 思路分析及问题  甲1122  题目描述 代码 思路分析及问题  甲1123  题目描述 代码 思路分析及问题  甲1124  题目描述 代码 思路分析及问题  甲1125  题目描述 代码 思路分析及问题  甲1126  题目描述 代码 思路分析及问题  甲1127  题目描述 代码 思路分析及问题  甲1128  题目描述 代码 思路分析及问题  甲1129  题目描述 代码 思路分析及问题  甲1130  题目描述 代码 思路分析及问题  甲1131  题目描述 代码 思路分析及问题  甲1132  题目描述 代码 思路分析及问题  甲1133  题目描述 代码 思路分析及问题  甲1134  题目描述 代码 思路分析及问题  甲1135  题目描述 代码 思路分析及问题  甲1136  题目描述 代码 思路分析及问题  甲1137  题目描述 代码 思路分析及问题  甲1138  题目描述 代码 思路分析及问题  甲1139  题目描述 代码 思路分析及问题  甲1140  题目描述 代码 思路分析及问题  "
},
{
	"uri": "http://example.org/machinelearning/recommendedsystem/",
	"title": "RecommendedSystem",
	"tags": [],
	"description": "",
	"content": "推荐系统 根据用户的兴趣特点和购买行为，向用户推荐用户感兴趣的信息和商品，推荐系统的产生是为了解决信息过载\n源数据： 要推荐物品或内容的元数据，如关键字，基因描述等；\n系统用户的基本信息，例如性别，年龄等\n用户对物品或信息的偏好，根据应用本身不同，可能包括用户对物品的评分，用户查看物品的记录，用户购买记录等。\n这些偏好信息可以分为两类：\n  显式的用户反馈\n这类是用户在网站上自然浏览或使用网站以外，显式地提供反馈信息，例如用户对商品的评论\n  隐式的用户反馈\n这类是用户在使用网站时产生的数据，隐式地反映了用户对物品的喜好，例如用户购买了某商品，查看了某商品的信息等\n  推荐系统架构 离线部分算模型、一部分列表\n在线部分算协同过滤(CF)、另一部分推荐列表\n推荐的一般步骤\n 需求分析(架构推荐方案) 数据清洗(得到训练数据) 算法建模(得到模型结果) 模型使用(得到推荐结果) 结果评估(推荐结果评估)  协同过滤 利用某兴趣相投、拥有共同经验之群体的喜好来推荐使用者感兴趣的资讯\n基于用户的协同过滤 给用户推荐和他兴趣相似的其他用户喜欢的物品\n1.收集用户资料\n2.最近邻搜索找到相似用户\n3.计算产生推荐结果\n以使用者为基础的协同推荐算法随着使用者数量的增多，计算 的时间就会变长\n社交网络站点中，UserCF是一个不错的选择\n基于物品的协同过滤 给用户推荐和他之前喜欢的物品相似的物品\n1.收集用户资料\n2.针对物品的最近邻搜索找到相似物品\n3.计算产生推荐结果\n是目前电子商务采用最广泛的推荐算法\n把数据看成空间中的向量(降噪、归一化)\n相似度计算  基于距离计算相似度（欧几里得） 基于相关系数计算相似度（皮尔逊相关系数） 皮尔逊相关系数一般用于计算两个变量间联系的紧密程度，它 的取值在[-1,+1]之间 基于夹角余弦计算相似度（Cosine Similarity） 基于Tanimoto谷本系数计算相似度，也称Jaccard系数，是 Cosine相似度的扩展，也用于计算文档数据的相似度 同现矩阵 （商品同现矩阵*用户对商品的评分矩阵=推荐结果）  邻居的圈定  邻居（用户、物品） 固定数量的邻居：K-neighborhoods 基于相似度门槛的邻居：Threshold-based neighborhood  通过虚拟机的方式，搭建Spark分布式集群 "
},
{
	"uri": "http://example.org/bigdata/spark/",
	"title": "Spark",
	"tags": [],
	"description": "",
	"content": "Spark环境搭建(Linux)  在Linux上搭建spark环境，使用VMWare,安装Ubuntu22.04系统\n1、安装JDK 参考文献：https://blog.csdn.net/ZhangYing_Jie/article/details/124314495\nsudo表示切换用户权限，也可以先 su root切换到root用户\n在/usr/local/中创建java目录\nsudo mkdir /usr/local/java Java官网下载jdk8\n解压JDK到java目录\nsudo tar -zxvf jdk-18_linux-x64_bin.tar.gz -C /usr/local/java/ 配置环境变量\nvi /etc/profile 按下字母i进入insert模式\n也可以使用gedit编辑\ngedit /etc/profile 打开文件后在末尾加入\nJAVA_HOME=/usr/local/java/jdk PATH=$JAVA_HOME/bin:$PATH CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar export PATH JAVA_HOME CLASSPATH 使得修改生效：\nsource /etc/profile 也可以直接使用如下命令安装JDK\nsudo apt install openjdk-8-jre-headless 检查是否安装成功：\njava -version 2、安装Scala  安装scala  ​\t按照提示安装即可，但是官网下载会很慢，还有可能被墙\n​\t使用镜像站(https://distfiles.macports.org/scala3.1/)，下载压缩包解压,配置环境变量\n​\t或者直接使用命令\nsudo apt install scala ​\t检查是否安装成功\n3、安装Spark 下载压缩包（https://www.apache.org/dyn/closer.lua/spark/spark-3.2.1/spark-3.2.1-bin-hadoop3.2.tgz）\n解压到/opt/spark-hadoop\n配置环境变量\n# java\nJAVA_HOME=/usr/local/java/jdk PATH=$JAVA_HOME/bin:$PATH CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar export PATH JAVA_HOME CLASSPATH\n#scala\nexport SCALA_HOME=/opt/scala3-3.1.2 export PATH=${SCALA_HOME}/bin:$PATH\n#spark\nexport SPARK_HOME=/opt/spark-hadoop/\nexport PYTHONPATH=/opt/spark-hadoop/python\n启动spark\n4、测试Spark可用 将py4j目录移动到python目录下\n启动python,调用pyspark\nSpark简介 根据 Hadoop MapReduce 的工作流程，可以分析出 Hadoop MapRedcue 的一些缺点。\n1）Hadoop MapRedue 的表达能力有限。\n所有计算都需要转换成 Map 和 Reduce 两个操作，不能适用于所有场景，对于复杂的数据处理过程难以描述。\n2）磁盘 I/O 开销大。\nHadoop MapReduce 要求每个步骤间的数据序列化到磁盘，所以 I/O 成本很高，导致交互分析和迭代算法开销很大，而几乎所有的最优化和机器学习都是迭代的。所以，Hadoop MapReduce 不适合于交互分析和机器学习。\n3）计算延迟高。\n如果想要完成比较复杂的工作，就必须将一系列的 MapReduce 作业串联起来然后顺序执行这些作业。每一个作业都是高时延的，而且只有在前一个作业完成之后下一个作业才能开始启动。因此，Hadoop MapReduce 不能胜任比较复杂的、多阶段的计算服务。\nSpark 是借鉴了 Hadoop MapReduce 技术发展而来的，继承了其分布式并行计算的优点并改进了 MapReduce 明显的缺陷。\nSpark 使用 Scala 语言进行实现，它是一种面向对象的函数式编程语言，能够像操作本地集合对象一样轻松地操作分布式数据集。它具有运行速度快、易用性好、通用性强和随处运行等特点，具体优势如下。\n1）Spark 提供了内存计算，把中间结果放到内存中，带来了更高的迭代运算效率。通过支持有向无环图（DAG）的分布式并行计算的编程框架，Spark 减少了迭代过程中数据需要写入磁盘的需求，提高了处理效率。\n**2）**Spark 为我们提供了一个全面、统一的框架，用于管理各种有着不同性质（文本数据、图表数据等）的数据集和数据源（批量数据或实时的流数据）的大数据处理的需求。\nSpark 使用函数式编程范式扩展了 MapReduce 模型以支持更多计算类型，可以涵盖广泛的工作流，这些工作流之前被实现为 Hadoop 之上的特殊系统。\nSpark 使用内存缓存来提升性能，因此进行交互式分析也足够快速，缓存同时提升了迭代算法的性能，这使得 Spark 非常适合数据理论任务，特别是机器学习。\n**3）Spark 比 Hadoop 更加通用。**Hadoop 只提供了 Map 和 Reduce 两种处理操作，而 Spark 提供的数据集操作类型更加丰富，从而可以支持更多类型的应用。\nSpark 的计算模式也属于 MapReduce 类型，但提供的操作不仅包括 Map 和 Reduce，还提供了包括 Map、Filter、FlatMap、Sample、GroupByKey、ReduceByKey、Union、Join、Cogroup、MapValues、Sort、PartionBy 等多种转换操作，以及 Count、Collect、Reduce、Lookup、Save 等行为操作。\n4）Spark 基于 DAG 的任务调度执行机制比 Hadoop MapReduce 的迭代执行机制更优越。\nSpark 各个处理结点之间的通信模型不再像 Hadoop 一样只有 Shuffle 一种模式，程序开发者可以使用 DAG 开发复杂的多步数据管道，控制中间结果的存储、分区等。\nRDD Spark 的核心是建立在统一的抽象弹性分布式数据集（Resiliennt Distributed Datasets，RDD）之上的\nRDD基本概念 通俗点来讲，可以将 RDD 理解为一个分布式对象集合，本质上是一个只读的分区记录集合。每个 RDD 可以分成多个分区，每个分区就是一个数据集片段。一个 RDD 的不同分区可以保存到集群中的不同结点上，从而可以在集群中的不同结点上进行并行计算。\nRDD 的分区及分区与工作结点（Worker Node）的分布关系：\nRDD 具有容错机制，并且只读不能修改，可以执行确定的转换操作创建新的 RDD。具体来讲，RDD 具有以下几个属性。\n 只读：不能修改，只能通过转换操作生成新的 RDD。 分布式：可以分布在多台机器上进行并行处理。 弹性：计算过程中内存不够时它会和磁盘进行数据交换。 基于内存：可以全部或部分缓存在内存中，在多次计算间重用。  RDD基本操作 RDD 的操作分为转化（Transformation）操作和行动（Action）操作。转化操作就是从一个 RDD 产生一个新的 RDD，而行动操作就是进行实际的计算。\nRDD 的操作是惰性的，当 RDD 执行转化操作的时候，实际计算并没有被执行，只有当 RDD 执行行动操作时才会促发计算任务提交，从而执行相应的计算操作。\n1、构建RDD\n  从内存里直接读取数据\nval rdd01 = sc.makeRDD(List(l,2,3,4,5,6))   从文件系统里读取数据（HDFS、本地文件系统等）\nval rdd:RDD[String] == sc.textFile(\u0026#34;file:///D:/sparkdata.txt\u0026#34;,1)   2、转换操作transformation\nRDD转换操作（rdd1={1, 2, 3, 3}，rdd2={3,4,5})\n   函数名 作用 示例 结果     map() 将函数应用于 RDD 的每个元素，返回值是新的 RDD rdd1.map(x=\u0026gt;x+l) {2,3,4,4}   flatMap() 将函数应用于 RDD 的每个元素，将元素数据进行拆分，变成迭代器，返回值是新的 RDD rdd1.flatMap(x=\u0026gt;x.to(3)) {1,2,3,2,3,3,3}   filter() 函数会过滤掉不符合条件的元素，返回值是新的 RDD rdd1.filter(x=\u0026gt;x!=1) {2,3,3}   distinct() 将 RDD 里的元素进行去重操作 rdd1.distinct() (1,2,3)   union() 生成包含两个 RDD 所有元素的新的 RDD rdd1.union(rdd2) {1,2,3,3,3,4,5}   intersection() 求出两个 RDD 的共同元素 rdd1.intersection(rdd2) {3}   subtract() 将原 RDD 里和参数 RDD 里相同的元素去掉 rdd1.subtract(rdd2) {1,2}   cartesian() 求两个 RDD 的笛卡儿积 rdd1.cartesian(rdd2) {(1,3),(1,4)\u0026hellip;\u0026hellip;(3,5)}    3、行动操作action\nRDD 行动操作（rdd={1,2,3,3}）\n   函数名 作用 示例 结果     collect() 返回 RDD 的所有元素 rdd.collect() {1,2,3,3}   count() RDD 里元素的个数 rdd.count() 4   countByValue() 各元素在 RDD 中的出现次数 rdd.countByValue() {(1,1),(2,1),(3,2})}   take(num) 从 RDD 中返回 num 个元素 rdd.take(2) {1,2}   top(num) 从 RDD 中，按照默认（降序）或者指定的排序返回最前面的 num 个元素 rdd.top(2) {3,3}   reduce() 并行整合所有 RDD 数据，如求和操作 rdd.reduce((x,y)=\u0026gt;x+y) 9   fold(zero)(func) 和 reduce() 功能一样，但需要提供初始值 rdd.fold(0)((x,y)=\u0026gt;x+y) 9   foreach(func) 对 RDD 的每个元素都使用特定函数 rdd1.foreach(x=\u0026gt;printIn(x)) 打印每一个元素   saveAsTextFile(path) 将数据集的元素，以文本的形式保存到文件系统中 rdd1.saveAsTextFile(file://home/test)    saveAsSequenceFile(path) 将数据集的元素，以顺序文件格式保存到指 定的目录下 saveAsSequenceFile(hdfs://home/test)     RDD血缘关系 RDD 的最重要的特性之一就是血缘关系（Lineage )，它描述了一个 RDD 是如何从父 RDD 计算得来的。如果某个 RDD 丢失了，则可以根据血缘关系，从父 RDD 计算得来。\n下图给出了一个 RDD 执行过程的实例。系统从输入中逻辑上生成了 A 和 C 两个 RDD， 经过一系列转换操作，逻辑上生成了 F 这个 RDD。\nSpark 记录了 RDD 之间的生成和依赖关系。当 F 进行行动操作时，Spark 才会根据 RDD 的依赖关系生成 DAG，并从起点开始真正的计算。\nRDD依赖类型 根据不同的转换操作，RDD 血缘关系的依赖分为窄依赖和宽依赖。窄依赖是指父 RDD 的每个分区都只被子 RDD 的一个分区所使用。宽依赖是指父 RDD 的每个分区都被多个子 RDD 的分区所依赖。\nRDD几大特性 五大特性：\n  A list of partitions\nRDD是由一系列partition组成(block块对应partition),textFile底层调用的是MR读取hdfs上的数据的方法\n默认一个block块对应一个split,split的大小和block大小一致,可以自己调整\n  A function for computing each split\n函数作用在每一个partition(split)上\n  A list of dependencies on other RDDs\nRDD之间有一系列的依赖关系(容错机制)\n  Optionally, a Partitioner for key-value RDDs\n分区器作用在K,V格式的RDD上\n  Optionally, a list of preferred locations to compute each split on\nRDD 提供一系列最佳的计算位置\n  Spark总体架构 Spark运行流程 Windows配置Spark https://blog.csdn.net/qq_52491380/article/details/120787037\nDocker\u0026ndash;Spark 安装docker后运行如下命令\njupyter/pyspark-notebook 是docker官方镜像\ndocker run -p 8888:8888 jupyter/pyspark-notebook 将docker容器内8888端口映射到本地的8888端口\nPySpark_Wordcount from pyspark import SparkConf, SparkContext from pyspark.storagelevel import StorageLevel  conf = SparkConf().setMaster(\u0026#34;local\u0026#34;).setAppName(\u0026#34;wordcount\u0026#34;) sc = SparkContext(conf=conf) sc.setCheckpointDir(\u0026#34;.\u0026#34;)  data1 = [\u0026#39;I like Edison Chan\u0026#39;, \u0026#39;I like Eason Chan\u0026#39;, \u0026#39;I love myself\u0026#39;] rdd1 = sc.parallelize(data1) result = rdd1.flatMap(lambda x: x.split()).map(lambda word: (word, 1)).reduceByKey(lambda x, y: x+y) result.foreach(print) 输出每一步的RDD：\nrdd1 = sc.parallelize(data1) rdd1.foreach(print) # result = rdd1.flatMap(lambda x: x.split()).map(lambda word: (word, 1)).reduceByKey(lambda x, y: x+y) # result.foreach(print) rdd2 = rdd1.flatMap(lambda x: x.split()) rdd2.foreach(print) rdd3 = rdd2.map(lambda word:(word,1)) rdd3.foreach(print) rdd4 = rdd3.reduceByKey(lambda x,y: x+y) rdd4.foreach(print) 原始数据：\nflat:\nmap:\nreduce:\nSpark\u0026ndash;MLlib MLlib 是 Spark 的机器学习库，旨在简化机器学习的工程实践工作，并方便扩展到更大规模。\nMLlib 由一些通用的学习算法和工具组成，包括分类、回归、聚类、协同过滤、降维等，同时还包括底层的优化原语和高层的管道 API。\n本节将对 Spark MLlib 进行简单介绍，在介绍数据挖掘算法时，将使用 Spark MLlib 提供的算法进行实例讲解。\nSpark MLlib的构成    名称 说明     数据类型 向量、带类别的向量、矩阵等   数学统计计算库 基本统计量、相关分析、随机数产生器、假设检验等   算法评测 AUC、准确率、召回率、F-Measure 等   机器学习算法 分类算法、回归算法、聚类算法、协同过滤等    "
},
{
	"uri": "http://example.org/algorithm/tooffer/",
	"title": "剑指Offer",
	"tags": [],
	"description": "",
	"content": "09.用两个栈实现队列   题目描述\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n示例 1：\n输入：\n[\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;]\n[[],[3],[],[]]\n输出：[null,null,3,-1]\n示例 2：\n输入：\n[\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;]\n[[],[],[5],[2],[],[]]\n输出：[null,-1,null,null,5,2]\n  代码\nclass CQueue { private:  stack\u0026lt;int\u0026gt; inStack, outStack;  void in2out() {  // 将in中的元素送入out，并从in删除  while (!inStack.empty()) {  outStack.push(inStack.top()); // top：取栈顶  inStack.pop(); // pop: 取栈顶并删除该元素  }  } public:  CQueue() {}  void appendTail(int value) {  inStack.push(value);  }  int deleteHead() {  if (outStack.empty()) {  if (inStack.empty()) {  return -1;  }  in2out();  }  int value = outStack.top();  outStack.pop();  return value;  } };   思路分析\n一个栈负责入队，一个栈负责出队\n  "
},
{
	"uri": "http://example.org/deeplearning/basic/",
	"title": "基础算法理论",
	"tags": [],
	"description": "",
	"content": "神经网络 激活函数：将神经元的净输入信号换成单一的输出信号，以便进一步在网络中传播\n网络拓扑：描述了模型中神经元的数量以及层数和它们连接的方式\n训练算法：指定如何设置连接权重，以便抑制或者增加神经元在输入信号中的比重 $$ y = f(Σ_0^nW_iX_i) $$ 其中f(·)为activation function 激活函数，W0为偏置项bias，对应的X0=1\n激活函数 sigmod $$ \\frac{1}{1+e^{-x}} $$\ntanh $$ \\frac{e^x-e^{-x}}{e^x+e^{-x}} $$\nrelu $$ max(0,x) $$\n网络拓扑 单层网络 只有输入层和输出层\n多层网络 除了输入层和输出层，中间还有隐藏层\n多节点输出网络 二分类：一个输出\n多分类：多个输出\n回归：一或多个输出\n训练算法 "
},
{
	"uri": "http://example.org/bigdata/",
	"title": "大数据",
	"tags": [],
	"description": "",
	"content": "大数据 参考文献\nhttp://c.biancheng.net/view/3500.html\nHadoop Spark "
},
{
	"uri": "http://example.org/vehicle/santana/",
	"title": "1:18 Santana",
	"tags": [],
	"description": "",
	"content": "1:18 模型 静改动(遥控) https://space.bilibili.com/109702523\n动力系统 转向机构 电路 灯光 自动驾驶 https://www.youtube.com/c/MOBATSim/\n"
},
{
	"uri": "http://example.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/programs/bodyassessment/imageprocess/",
	"title": "ImageProcess",
	"tags": [],
	"description": "",
	"content": "滤波 采用双边滤波平滑人体内部\n水平集 1、Localizing Region-Based Active Contours 2022-03-12 —— 2022-04-09\n  代码流程：\n  初始化轮廓为一个包含人体的矩形，内部为+c，外部为-c。（c=2）\n  开始演化\n  计算狄拉克函数\n作用是表明轮廓曲线周围的区域\n从上到下依次是：边界，远离边界的区域，和边界附近的区域\n  计算曲率\n一阶导：, || = 先对一阶导数单位化，再求二阶导数\n曲率curvature = + 即  计算前景与背景均值\n  先计算Heaviside函数，标识水平集的内部和外部（内部为1，外部为0，边界为0~1）\n  计算前景均值\n  计算背景均值\n    计算惩罚项\n将phi与一个拉普拉斯算子做卷积运算，以突出phi的边缘\n  更新phi的每个点的值\n      实验：\n  参数\nc为水平集内部点的初值\n  结果\n    ​\t​\t​\t左图为最终的轮廓，右图为最终的水平集phi可以看到都没有平滑，调整迭代次数，时间步长，λ，μ，ν，都没有明显的效果（220326周报-全局调参）。\n​\t220402—统计时间（microseconds），尝试初始轮廓换成椭圆\n   方法 患者ID 矩形水平集20轮 椭圆水平集30轮 椭圆水平集 20轮     1 409061 632310 396968   2 410979 592415 359038   3 415397 575459 360009   4 414089 596375 356047   5 399128 566481 358014   6 391003 560502 363057   7 385457 585406 363056   8 403885 561497 355049   9 389965 547533 370980   10 385965 527591 355050   11 389469 508668 358071   12 396982 501630 363055   13 395966 496705 365023   14 395943 505646 361034   15 389438 502631 351089   16 400473 497695 349039   17 391429 516645 358040   18 381009 503682 361034   19 429991 506644 354081   均值 398717.3158 541342.8947 360933.3684    考虑到初始轮廓也可能会影响水平集方法的效果，所以尝试了用椭圆作为初始轮廓\n水平集方法按照初步调参后效果比较好的参数进行时间统计\n矩形：迭代20次，演化步长m_timestep为0.01，m_lambda=0.01，m_mu=1.0. m_nu=1.0\n椭圆：迭代30次，演化步长m_timestep为0.01，m_lambda=0.01，m_mu=1.0. m_nu=1.0\n都没有明显的平滑效果。\n2、Distance Regularized Level Set Evolution and Its Application to Image Segmentation DRLSE 2022-04-09 —— 2022-05-14\n  代码流程\n  深度图转换成灰度图\nlow和high分别为深度值的最小和最大值\n  去除srcImg中灰度大于100的部分，以去除相对人体较亮的背景\n  求edge indicator g\n先对srcImg进行高斯滤波得到gbImg\n对gbImg求梯度dx,dy,得到计算g\n​\t目标边界的g值通常比其他区域要小\n  初始化轮廓为人体内部的两个矩形\n  开始演化\n    实验\n 参数 结果    3、Fast Global Minimization of the Active Contour/Snake Model GMAC 2022-05-14 —— 2022-05-28\n4、尝试结合前面的三种模型 对点云图进行处理 2022-06-01——\n思路 分辨率、边缘平滑\nKinect相机→深度图/彩色图→点云→插值提高分辨率、保持边缘平滑、滤波→映射到二维深度图/灰度图\n整理获取图像的流程 启动界面BdAssessment，在其构造函数中新建了一个camera实例，以及一个控制相机显示的QTimer定时器\n定时器发出超时信号，触发槽函数cameraDisplay()\nstart(0)：时间间隔0毫秒，一旦窗口系统事件队列中的所有事件都已经被处理完，该QTimer就会到时间了，进行cameraDisplay()\nBdAssessment::BdAssessment(QWidget *parent): QMainWindow(parent) { \tcamera = new Camera();  cameraDisplayTimer = new QTimer();  connect(cameraDisplayTimer, SIGNAL(timeout()), this, SLOT(cameraDisplay()));  cameraDisplayTimer-\u0026gt;start(0); } 启动Kinect设备\nCamera::Camera() { \topenDevice(); } 进入cameraDisplay()\n  camera→getFrame() 获取一帧图像\ngetFrame()是一个重载函数\nUINT16* getFrame(float floorH); UINT16* getFrame(float floorH, bool\u0026amp; isBody); BYTE* getFrame(float floorH, int mode); 这里用的是第一个，getFrame(setting-\u0026gt;getHeight())，floorH是相机高度\nfloat Setting::getHeight() { \treturn ui.heightValue-\u0026gt;text().toFloat(); } IDepthFrame* pDepthFrame = nullptr; IColorFrame* pColorFrame = nullptr;\tIDepthFrameReader* m_pDepthFrameReader = nullptr; IColorFrameReader* m_pColorFrameReader = nullptr; IDepthFrame 和 IColorFrame 是Kinect中的两个类，分别用来存储深度图像和彩色图像\nIDepthFrameReader和IColorFrameReader 是Kinect中的两个类，分别用来读取深度图像和彩色图像\n1）读取深度图像\nhr = m_pDepthFrameReader-\u0026gt;AcquireLatestFrame(\u0026amp;pDepthFrame); 返回值hr表示读取是否成功\nif (SUCCEEDED(hr)) {  if (frameId \u0026gt; 149)  {  frameId++;  SafeRelease(pDepthFrame);  return depthBuffers + (frameId % 150) * 424 * 512;  }  hr = pDepthFrame-\u0026gt;CopyFrameDataToArray(depthHeight * depthWidth, depthBuffers + frameId * 424 * 512); } CopyFrameDataToArray将Kinect中的帧数据转换成一维数组(depthBuffers)，\ndepthHeight * depthWidth(424*512)为一帧的像素个数\nframeId（初值为0）用来记录帧数，最多150帧（行走图共有150帧）,存满150帧就返回depthBuffers，然后一帧一帧地返回\n2）读取彩色图像\nif (SUCCEEDED(hr)) { \thr = m_pColorFrameReader-\u0026gt;AcquireLatestFrame(\u0026amp;pColorFrame); } if (SUCCEEDED(hr)) {  hr = pColorFrame-\u0026gt;CopyConvertedFrameDataToArray(1080*1920*4, reinterpret_cast\u0026lt;BYTE*\u0026gt;(i_rgb.data), ColorImageFormat::ColorImageFormat_Bgra); } SafeRelease(pDepthFrame); SafeRelease(pColorFrame); 彩色图像是bgra四通道格式的，尺寸为1080*1920，存储到 cv::Mat i_rgb; 中\n3）数据预处理\nif (SUCCEEDED(hr)) {  float h = floorH;  for (int i = 0; i \u0026lt; depthHeight; i++)  {  for (int j = 0; j \u0026lt; depthWidth; j++)  {  DepthSpacePoint depthSpacePoint;  depthSpacePoint = { static_cast\u0026lt;float\u0026gt;(j), static_cast\u0026lt;float\u0026gt;(i) };  UINT16 currDepth = depthBuffers[i * depthWidth + j + frameId * 424 * 512];  CameraSpacePoint cameraPoint = { 0.0f, 0.0f, 0.0f };  ColorSpacePoint colorPoint = { 0.0f, 0.0f };  m_pMap-\u0026gt;MapDepthPointToCameraSpace(depthSpacePoint, currDepth, \u0026amp;cameraPoint);  if (cameraPoint.Y \u0026lt; -h || j\u0026lt;99 || j\u0026gt;99+318)  depthBuffers[i * depthWidth + j + frameId * 424 * 512] = 0;  }  }  UINT16* img = depthBuffers + frameId * 424 * 512;  /***************************************************************************************************/   BYTE* label = new BYTE[depthHeight * depthWidth]();  label[seedY * depthWidth + seedX] = 1;  queue\u0026lt;int\u0026gt; points;  points.push(seedX);  points.push(seedY);  int nearby[] = { 1, 0, -1, 0, 0, 1, 0, -1 };  int nn = 0;  while (!points.empty())  {  int x = points.front();  points.pop();  int y = points.front();  points.pop();  int value = img[y * depthWidth + x];  for (int i = 0; i \u0026lt; 4; i++)  {  int xx = x + nearby[i * 2 + 0];  int yy = y + nearby[i * 2 + 1];  xx = min(max(0, xx), depthWidth - 1);  yy = min(max(0, yy), depthHeight - 1);  if (abs(img[yy * depthWidth + xx] - value) \u0026lt; d \u0026amp;\u0026amp; label[yy*depthWidth + xx] == 0)  {  label[yy * depthWidth + xx] = 1;  nn++;  points.push(xx);  points.push(yy);  }  }  }  for (int i = 0; i \u0026lt; depthHeight; i++)  for (int j = 0; j \u0026lt; depthWidth; j++)  if (label[i*depthWidth + j] == 0)  img[i * depthWidth + j] = 0;   /***************************************************************************************************/  if (record)  {  /*if (colorFlag) { cv::Mat i_rgb2; cvtColor(i_rgb, i_rgb2, CV_RGBA2RGB); i_rgbs.push_back(i_rgb2); }*/  frameId++;  }  return img;  }  return nullptr; } DepthSpacePoint，CameraDepthPoint，ColorDepthPoint是kinect中的一个结构体\ntypedef struct _DepthSpacePoint  {  float X;  float Y;  } DepthSpacePoint;  typedef struct _CameraSpacePoint  {  float X;  float Y;  float Z;  } CameraSpacePoint;  typedef struct _ColorSpacePoint  {  float X;  float Y;  } ColorSpacePoint; depthSpacePoint = { static_cast\u0026lt;float\u0026gt;(j), static_cast\u0026lt;float\u0026gt;(i) }; CameraSpacePoint cameraPoint = { 0.0f, 0.0f, 0.0f }; ColorSpacePoint colorPoint = { 0.0f, 0.0f };\tj是列索引，i是行索引，分别对应X和Y坐标，所以坐标系如下：\ncurrDepth为深度图像的深度值\n将深度坐标转换为相机坐标，Z即为深度值\nm_pMap-\u0026gt;MapDepthPointToCameraSpace(depthSpacePoint, currDepth, \u0026amp;cameraPoint); 将比人体所在区域高和低的部分的深度值置为0\nif (cameraPoint.Y \u0026lt; -h || j\u0026lt;99 || j\u0026gt;99+318)  depthBuffers[i * depthWidth + j + frameId * 424 * 512] = 0; 取当前的帧\nUINT16* img = depthBuffers + frameId * 424 * 512; 区域增长分割人体(队列、深度差阈值)\nBYTE* label = new BYTE[depthHeight * depthWidth](); label[seedY * depthWidth + seedX] = 1; queue\u0026lt;int\u0026gt; points; points.push(seedX); points.push(seedY); int nearby[] = { 1, 0, -1, 0, 0, 1, 0, -1 }; int nn = 0; while (!points.empty()) {  int x = points.front();  points.pop();  int y = points.front();  points.pop();  int value = img[y * depthWidth + x];  for (int i = 0; i \u0026lt; 4; i++)  {  int xx = x + nearby[i * 2 + 0];  int yy = y + nearby[i * 2 + 1];  xx = min(max(0, xx), depthWidth - 1);  yy = min(max(0, yy), depthHeight - 1);  if (abs(img[yy * depthWidth + xx] - value) \u0026lt; d \u0026amp;\u0026amp; label[yy*depthWidth + xx] == 0)  {  label[yy * depthWidth + xx] = 1;  nn++;  points.push(xx);  points.push(yy);  }  } } for (int i = 0; i \u0026lt; depthHeight; i++)  for (int j = 0; j \u0026lt; depthWidth; j++)  if (label[i*depthWidth + j] == 0)  img[i * depthWidth + j] = 0; 返回分割人体后的帧，record表示是否录像\nif (record) { \tframeId++; } return img;   回到cameraDisplay()\nUINT16* depthImg = camera-\u0026gt;getFrame(setting-\u0026gt;getHeight()); if (depthImg == nullptr) \treturn; UINT16 depth = depthImg[seedY*depthWidth + seedX]; DepthSpacePoint depthSpacePoint = { static_cast\u0026lt;float\u0026gt;(seedX), static_cast\u0026lt;float\u0026gt;(seedY) }; CameraSpacePoint cameraPoint = { 0.0f, 0.0f, 0.0f }; camera-\u0026gt;m_pMap-\u0026gt;MapDepthPointToCameraSpace(depthSpacePoint, depth, \u0026amp;cameraPoint);//将深度图坐标转换到相机坐标 depthImg是camera-\u0026gt;getFrame()返回的分割出人体后的深度图\nseedX = depthWidth / 2; seedY = depthHeight / 2; 是中心种子点的坐标，depth为其深度值\ncameraPoint为人体种子点对应的相机坐标（X,Y,Z）\nif (cameraPoint.Z == -std::numeric_limits\u0026lt;float\u0026gt;::infinity())  ui.label_14-\u0026gt;setText(QStringLiteral(\u0026#34;未检测出物体\u0026#34;)); else{  ui.label_14-\u0026gt;setText(QStringLiteral(\u0026#34;距离： \u0026#34;) + QString::number(cameraPoint.Z) + \u0026#34;m\u0026#34;);  tempDis = cameraPoint.Z; } 根据种子点深度值判断是否检测出人体，\ntempDis为种子点离相机的距离，单位为m，后面需要用来判断拍摄的照片是否符合要求\nif (tempDis * 100 \u0026gt;= 230 || tempDis * 100 \u0026lt;= 170) {  mess = QStringLiteral(\u0026#34;请调整您与摄像头的距离！\u0026#34;);  flag = true; } 如果帧数达到150，保存录像\nif (camera-\u0026gt;frameId == 150) {  cameraDisplayTimer-\u0026gt;stop();  cameraDisplayTimer-\u0026gt;start(0);  saveVideo(); } 将深度值转换为灰度值[0,255]\nfor (int i = 0; i \u0026lt; 424 * 512; i++)  depthBuffers[i] = depthImg[i] % 256; 将种子点附近的值置为255\nfor (int i = seedY - 5; i \u0026lt; seedY + 5; i++)  for (int j = seedX - 20; j \u0026lt; seedX + 20; j++)  depthBuffers[i * depthWidth + j] = 255; for (int i = seedY - 20; i \u0026lt; seedY + 20; i++)  for (int j = seedX - 5; j \u0026lt; seedX + 5; j++)  depthBuffers[i * depthWidth + j] = 255; 显示\nQImage depthImgQ = QImage(depthBuffers, depthWidth, depthHeight, QImage::Format_Grayscale8); QImage depthImgROI = depthImgQ.copy(depthWidth / 2 - depthHeight * 3 / 8, 0, depthHeight * 3 / 4, depthHeight); depthImgROI = depthImgROI.scaled(ui.depthFig-\u0026gt;width(), ui.depthFig-\u0026gt;height()); ui.depthFig-\u0026gt;setPixmap(QPixmap::fromImage(depthImgROI)); \n  拍照\n点击“拍”按钮，调用函数BdAssessment::capture()\ncameraDisplayTimer-\u0026gt;stop(); QDir currDir(\u0026#34;./\u0026#34;); if (!currDir.exists(\u0026#34;Data2\u0026#34;))  currDir.mkdir(\u0026#34;Data2\u0026#34;); 首先停止cameraDisplay，然后创建存储数据的目录Data2\n调用Camer::capture()\nbool isBody = false; UINT16* depthImg = camera-\u0026gt;capture(setting-\u0026gt;getHeight(), isBody); UINT16* Camera::capture(float floorH, bool\u0026amp; isBody) { \tUINT16* img; \twhile (1) \t{ \timg = getFrame(floorH, isBody); \tif (img != nullptr) \treturn img; \t} } 这里的getFrame和前面的getFrame基本一帧，只是多了下面这一段：\nIBodyFrame* pBodyFrame = nullptr; IBodyFrameSource* pBodyFrameSource = nullptr; IBodyFrameReader* m_pBodyFrameReader = nullptr;  if (SUCCEEDED(hr)) {  m_pBodyFrameReader-\u0026gt;AcquireLatestFrame(\u0026amp;pBodyFrame); } if (SUCCEEDED(hr)) {  IBody** myBodyArr = new IBody *[BODY_COUNT];  for (int i = 0; i \u0026lt; BODY_COUNT; i++)  myBodyArr[i] = nullptr;  if (pBodyFrame-\u0026gt;GetAndRefreshBodyData(BODY_COUNT, myBodyArr) == S_OK) //把身体数据输入数组  {  for (int i = 0; i \u0026lt; BODY_COUNT; i++)  {  BOOLEAN result = false;  if (myBodyArr[i]-\u0026gt;get_IsTracked(\u0026amp;result) == S_OK \u0026amp;\u0026amp; result) //先判断是否侦测到  {  isBody = true;  break;  }  }  } } IBodyFrame，IBodyFrameSource，IBodyFrameReader也是Kinect中的类，用来判断是否侦测到身体。\n最终depthImg为getFrame()返回的分割人体后的帧\nUINT16* depthImg = camera-\u0026gt;capture(setting-\u0026gt;getHeight(), isBody); /*if (!isBody) //人体检测 { QMessageBox::information(NULL, QStringLiteral(\u0026#34;提示\u0026#34;), QStringLiteral(\u0026#34;未检测到人体，请重新拍摄\u0026#34;)); cameraDisplayTimer-\u0026gt;start(0); return; }*/ isBody是引用类型，getFrame内部通过Kinect接口判断是否检测到人体后，在capture()中根据isBody是否为true给出提示。\n保存数据\nstring depthFrameName = \u0026#34;./Data2/Depth_\u0026#34; + to_string(curId) + \u0026#34;_\u0026#34; + to_string(nextSubId) + \u0026#34;.dat\u0026#34;; ofstream f2(depthFrameName, ios::binary); f2.write(reinterpret_cast\u0026lt;char*\u0026gt;(depthImg), depthHeight * depthWidth * sizeof(UINT16)); f2.close(); 文件名为”Depth_\u0026hellip;\u0026hellip;..“的数据是分割出人体后的深度图。（还没有做滤波等处理）\n进行图像处理，其中iProFront和iProBack为ImageProcess类的实例\nswitch (nextSubId) { \tcase 1: \tiProFront-\u0026gt;terminate(); \tiProFront-\u0026gt;fileId = curId; \tiProFront-\u0026gt;subId = nextSubId; \tiProFront-\u0026gt;m_pMap = camera-\u0026gt;m_pMap; \tiProFront-\u0026gt;depthHeight = depthHeight; \tiProFront-\u0026gt;depthWidth = depthWidth; \tiProFront-\u0026gt;seedX = seedX; \tiProFront-\u0026gt;seedY = seedY; \tiProFront-\u0026gt;start(); \tbreak; \tcase 2: \tiProBack-\u0026gt;terminate(); \tiProBack-\u0026gt;fileId = curId; \tiProBack-\u0026gt;subId = nextSubId; \tiProBack-\u0026gt;m_pMap = camera-\u0026gt;m_pMap; \tiProBack-\u0026gt;depthHeight = depthHeight; \tiProBack-\u0026gt;depthWidth = depthWidth; \tiProBack-\u0026gt;seedX = seedX; \tiProBack-\u0026gt;seedY = seedY; \tiProBack-\u0026gt;start(); \tbreak; }\t\n图像处理类（ImageProcess） 将深度图像转换成点云是在这里实现的\nvoid ImageProcess::run() { \tint result; \tstring depthFrameName = \u0026#34;./Data2/Depth_\u0026#34; + to_string(fileId) + \u0026#34;_\u0026#34; + to_string(subId) + \u0026#34;.dat\u0026#34;; \tstring cloudName = \u0026#34;./Data/Cloud_\u0026#34; + to_string(fileId) + \u0026#34;_\u0026#34; + to_string(subId) + \u0026#34;.dat\u0026#34;; \tstring depthPName = \u0026#34;./Data/DepthP_\u0026#34; + to_string(fileId) + \u0026#34;_\u0026#34; + to_string(subId) + \u0026#34;.dat\u0026#34;; \tstring depthP2Name = \u0026#34;./Data/DepthPP_\u0026#34; + to_string(fileId) + \u0026#34;_\u0026#34; + to_string(subId) + \u0026#34;.dat\u0026#34;; \tQFileInfo file2(QString::fromStdString(depthFrameName)); \tif (!(file2.isFile())) \treturn; \tf2.open(depthFrameName, ios::binary); \tf3.open(cloudName, ios::binary); \tf4.open(depthPName, ios::binary); \tf5.open(depthP2Name, ios::binary); \tint frameNum; \tif (subId == 3) \tframeNum = 150; \telse \tframeNum = 1; \tfor (int i = 0; i \u0026lt; frameNum; i++) \t{ \tif (frameNum == 150) \t{ \tofstream f(\u0026#34;num.txt\u0026#34;); \tf \u0026lt;\u0026lt; i/2; \tf.close(); \t} \tloadData(); \tresult = extractBody(); \toutputFile(); \t} \tif (subId != 3) { \tofstream f(\u0026#34;num.txt\u0026#34;); \tf \u0026lt;\u0026lt; 150 / 2; \tf.close(); \t} \tf2.close(); \tf3.close(); \tf4.close(); \tf5.close(); \tdeepLearning(); \tcompressData();  } depthFrameName，前面capture存储的分割出人体的深度图\ncloudName，\ndepthPName ，\ndepthP2Name，\n根据subId判断是正面还是背面或者行走图，设置帧数frameNum，然后遍历每一帧进行处理\nfor (int i = 0; i \u0026lt; frameNum; i++) {  if (frameNum == 150)  {  ofstream f(\u0026#34;num.txt\u0026#34;);  f \u0026lt;\u0026lt; i/2;  f.close();  }  loadData();  result = extractBody();  outputFile(); } loadData()读取深度图像，存储至depthBuffer\n//读取深度图图像 void ImageProcess::loadData() { \tf2.read(reinterpret_cast\u0026lt;char*\u0026gt;(depthBuffer), depthHeight * depthWidth * sizeof(UINT16)); \tfor (int i = 0; i \u0026lt; depthHeight; i++) \tfor (int j = 0; j \u0026lt; depthWidth; j++) \tif (j \u0026gt; depthWidth / 2 + depthHeight / 4 || j \u0026lt; depthWidth / 2 - depthHeight / 4) \tdepthBuffer[i*depthWidth + j] = 0; } \nresult = extractBody();\n  extractBody：\n// ------------------------区域生长---------------------------- int d = 20; BYTE* label = new BYTE[depthHeight * depthWidth](); label[seedY * depthWidth + seedX] = 1; queue\u0026lt;int\u0026gt; points; points.push(seedX); points.push(seedY); int nearby[] = { 1, 0, -1, 0, 0, 1, 0, -1 }; int nn = 0; while (!points.empty()) {  int x = points.front();  points.pop();  int y = points.front();  points.pop();  int value = depthBuffer[y * depthWidth + x];  for (int i = 0; i \u0026lt; 4; i++)  {  int xx = x + nearby[i * 2 + 0];  int yy = y + nearby[i * 2 + 1];  xx = min(max(0, xx), depthWidth-1);  yy = min(max(0, yy), depthHeight-1);  if (abs(depthBuffer[yy * depthWidth + xx] - value) \u0026lt; d \u0026amp;\u0026amp; label[yy*depthWidth+xx]==0)  {  label[yy * depthWidth + xx] = 1;  nn++;  points.push(xx);  points.push(yy);  }  } }  // ------------------------二次遍历，将没有标记的数据深度置为0------------------------ int hist[10000] = { 0 }, low = 10000, high = 0; int up = depthHeight, down = 0, left = depthWidth, right = 0; for (int i = 0; i \u0026lt; depthHeight; i++) {  for (int j = 0; j \u0026lt; depthWidth; j++)  {  if (label[i*depthWidth+j] == 1)  {  UINT16 value = depthBuffer[i * depthWidth + j];  depthBuffer2[i * depthWidth + j] = value;  hist[value] += 1;  if (hist[value] \u0026gt; 5)  {  if (value \u0026gt; high)  high = value;  if (value \u0026lt; low)  low = value;  }  if (i \u0026lt; up)  up = i;  if (i \u0026gt; down)  down = i;  if (j \u0026lt; left)  left = j;  if (j \u0026gt; right)  right = j;  }  else  depthBuffer2[i * depthWidth + j] = 0;  } } 利用队列和深度差进行区域生长分割人体，结果存储至depthBuffer2\nup,down,left,right分别为人体(label==1)的上下左右坐标极值(即人体的第一/最后一行/列)\nhigh和low为深度值的最大最小(需要至少出现5次,出现5次以下的深度值不予考虑)\n平滑处理，可以用均值滤波、高斯滤波、双边滤波等，结果存储至depthBuffer3\n//--------------------------图像平滑处理-----------------------------(平滑只是简单的均值滤波，用双边滤波可以改进) int* depthBuffer3 = new int[depthHeight * depthWidth](); for (int i = 2; i \u0026lt; depthHeight-2; i++) {  for (int j = 2; j \u0026lt; depthWidth-2; j++)  {  if (depthBuffer2[i * depthWidth + j] == 0 || i == 0 || j == 0 || i == depthHeight-1 || j == depthWidth-1)  continue;  int nearX[] = { -2, -1, 0, 1, 2, -2, -1, 0, 1, 2, -2, -1, 0, 1, 2, -2, -1, 0, 1, 2, -2, -1, 0, 1, 2 };  int nearY[] = { -2, -2, -2, -2, -2, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 };  int k = 0;  for (k = 0; k \u0026lt; 25; k++)  {  if (depthBuffer2[(i + nearX[k]) * depthWidth + j + nearY[k]] == 0)  break;  depthBuffer3[i * depthWidth + j] += depthBuffer2[(i + nearX[k]) * depthWidth + j + nearY[k]];  }  if (k == 25)  depthBuffer3[i * depthWidth + j] /= 25;  else  depthBuffer3[i * depthWidth + j] = depthBuffer2[i * depthWidth + j];  } } \n计算点云坐标\nfor (int i = 0; i \u0026lt; depthHeight; i++) {  for (int j = 0; j \u0026lt; depthWidth; j++)  {  if (depthBuffer3[i * depthWidth + j] == 0)  {  cloudPoints[(i * depthWidth + j) * 3 + 0] = 0;  cloudPoints[(i * depthWidth + j) * 3 + 1] = 0;  cloudPoints[(i * depthWidth + j) * 3 + 2] = 0;  continue;  }  DepthSpacePoint depthSpacePoint;  if (depthHeight == 424)  depthSpacePoint = { static_cast\u0026lt;float\u0026gt;(j), static_cast\u0026lt;float\u0026gt;(i) };  else  depthSpacePoint = { static_cast\u0026lt;float\u0026gt;(i), static_cast\u0026lt;float\u0026gt;(j) };  UINT16 depth = depthBuffer3[i * depthWidth + j];  CameraSpacePoint cameraSpacePoint = { 0.0f, 0.0f, 0.0f };  m_pMap-\u0026gt;MapDepthPointToCameraSpace(depthSpacePoint, depth, \u0026amp;cameraSpacePoint);  if (depthHeight==424)  {  cloudPoints[(i * depthWidth + j) * 3 + 0] = cameraSpacePoint.X;  cloudPoints[(i * depthWidth + j) * 3 + 1] = cameraSpacePoint.Y;  cloudPoints[(i * depthWidth + j) * 3 + 2] = cameraSpacePoint.Z;  }  else  {  cloudPoints[(i * depthWidth + j) * 3 + 0] = cameraSpacePoint.Y;  cloudPoints[(i * depthWidth + j) * 3 + 1] = -cameraSpacePoint.X;  cloudPoints[(i * depthWidth + j) * 3 + 2] = cameraSpacePoint.Z;  }  if (depth \u0026gt;= low \u0026amp;\u0026amp; depth \u0026lt;= high)  depthBuffer2[i * depthWidth + j] = (depthBuffer3[i * depthWidth + j] - low) * 256 / (high - low);  else  depthBuffer2[i * depthWidth + j] = 0;  } } 一维数组cloudPoints：\n   X1 Y1 Z1 X2 Y2 Z2 \u0026hellip; \u0026hellip; \u0026hellip; Xn Yn Zn    根据像素点的下标（i,j）生成depthSpacePoint(x,y)，然后利用depthSpacePoint和深度值depth生成相机空间坐标cameraSpacePoint(x,y,z)\n点云坐标即为相机空间坐标\ncloudPoints[(i * depthWidth + j) * 3 + 0] = cameraSpacePoint.X; cloudPoints[(i * depthWidth + j) * 3 + 1] = cameraSpacePoint.Y; cloudPoints[(i * depthWidth + j) * 3 + 2] = cameraSpacePoint.Z; \n对depthBuffer2进行归一化[0,256]\nif (depth \u0026gt;= low \u0026amp;\u0026amp; depth \u0026lt;= high)  depthBuffer2[i * depthWidth + j] = (depthBuffer3[i * depthWidth + j] - low) * 256 / (high - low); else  depthBuffer2[i * depthWidth + j] = 0; \n遍历每一个像素点，如果其左右两个点的深度为0，就将其坐标置为(0，0，0)\nfor (int i = 1; i \u0026lt; depthHeight-1; i++) {  for (int j = 1; j \u0026lt; depthWidth-1; j++)  {  float z1 = cloudPoints[(i * depthWidth + j) * 3 + 2];  float z2 = cloudPoints[(i * depthWidth + j + 1) * 3 + 2];  float z3 = cloudPoints[(i * depthWidth + j - 1) * 3 + 2];  if (z1 != 0 \u0026amp;\u0026amp; z2 == 0 \u0026amp;\u0026amp; z3 == 0)  {  cloudPoints[(i * depthWidth + j) * 3 + 0] = 0;  cloudPoints[(i * depthWidth + j) * 3 + 1] = 0;  cloudPoints[(i * depthWidth + j) * 3 + 2] = 0;  }  } } \n存储人体所在的区域的数据\nheight为人体高度，weidth为人体宽度，一维数组input2的前四个值为人体的up\\down\\left\\right\n存储至文件”DepthPP_\u0026hellip;\u0026hellip;..“\nint height = down - up + 1; int width = right - left + 1;  UINT16* input2 = new UINT16[height*width + 4](); input2[0] = up; input2[1] = down; input2[2] = left; input2[3] = right; for (int i = 0; i \u0026lt; height; i++) {  for (int j = 0; j \u0026lt; width; j++)  {  int x = left + j;  int y = up + i;  input2[i*width + j + 4] = depthBuffer2[y*depthWidth + x];  } } f5.write(reinterpret_cast\u0026lt;char*\u0026gt;(input2), (height* width + 4) * sizeof(UINT16)); delete[] input2; 同上\n存储至文件”DepthP_\u0026hellip;\u0026hellip;..“\nint height1, height2; if (subId == 1)  height1 = 1, height2 = height; if (subId \u0026gt;= 2)  height1 = 1, height2 = height; down = up + height2 - 1; up = up + height1 - 1; height = height2 - height1 + 1;  UINT16* input = new UINT16[height * width + 4]();  input[0] = up; input[1] = down; input[2] = left; input[3] = right; for (int i = 0; i \u0026lt; height; i++) {  for (int j = 0; j \u0026lt; width; j++)  {  int x = left + j;  int y = up + i;  input[i*width + j + 4] = depthBuffer2[y*depthWidth + x];  } } f4.write(reinterpret_cast\u0026lt;char*\u0026gt;(input), (height* width + 4) * sizeof(UINT16)); \n  outputFile();\n  将点云cloudPoint存储至文件”Cloud_\u0026hellip;\u0026hellip;“\n//输出分割后的点云 void ImageProcess::outputFile() { \tf3.write(reinterpret_cast\u0026lt;char*\u0026gt;(cloudPoints), depthHeight * depthWidth * 3 * sizeof(FLOAT)); }    deepLearning();\n深度学习预测关键点\nvoid ImageProcess::deepLearning() { \tstring fileName; \tQFileInfo file;  \tif (subId == 1) { \tfileName = \u0026#34;DepthPP_\u0026#34; + to_string(fileId) + \u0026#34;_1.dat\u0026#34;; \tfile.setFile(QString::fromStdString(\u0026#34;./Data/DepthP_\u0026#34; + to_string(fileId) + \u0026#34;_1.dat\u0026#34;)); \t} \telse if (subId == 2) { \tfileName = \u0026#34;DepthP_\u0026#34; + to_string(fileId) + \u0026#34;_2.dat\u0026#34;; \tfile.setFile(QString::fromStdString(\u0026#34;./Data/DepthP_\u0026#34; + to_string(fileId) + \u0026#34;_2.dat\u0026#34;)); \t} \telse if (subId == 3){ \tfileName = \u0026#34;DepthP_\u0026#34; + to_string(fileId) + \u0026#34;_3.dat\u0026#34;; \tfile.setFile(QString::fromStdString(\u0026#34;./Data/DepthP_\u0026#34; + to_string(fileId) + \u0026#34;_3.dat\u0026#34;)); \t}  \t//当正面 背面 走路全录入后 一起送进网络进行预测 \tif (file.isFile()) \t{ \tstring mCommand = \u0026#34;predict/predict \u0026#34;; \tmCommand += fileName; \tWinExec(mCommand.c_str(), SW_HIDE); \t} } \n  compressData();\n压缩点云文件\ncompress(buf, \u0026amp;bufLen, cloud, cloudLen)\ncompress是第三方库zlib中压缩数据的函数\n  //压缩点云文件、删除原始深度图像数据、压缩分割后深度图像视频 void ImageProcess::compressData() { \tunsigned long Len; \tif (subId == 3) \tLen = 424 * 512 * 3 * 150 * sizeof(FLOAT); \telse \tLen = 424 * 512 * 3 * sizeof(FLOAT);  \tstring cloudName = \u0026#34;./Data/Cloud_\u0026#34; + to_string(fileId) + \u0026#34;_\u0026#34; + to_string(subId) + \u0026#34;.dat\u0026#34;; \tf2.open(cloudName, ios::binary); \tunsigned char* cloud = new unsigned char[Len]; \tunsigned long cloudLen = Len; \tf2.read(reinterpret_cast\u0026lt;char*\u0026gt;(cloud), cloudLen); \tf2.close(); \tunsigned char* buf = new unsigned char[Len]; \tunsigned long bufLen = Len; \tcompress(buf, \u0026amp;bufLen, cloud, cloudLen); \tf3.open(cloudName, ios::binary); \tf3.write(reinterpret_cast\u0026lt;char*\u0026gt;(buf), bufLen); \tf3.close(); \tdelete[] buf; \tdelete[] cloud; } 显示点云（dataProcess项目） 用PCL渲染点云\n//-------------------------------点云渲染------------------------------------ cloud-\u0026gt;clear(); for (int i = 0; i \u0026lt; dephtHeight; i++) { \tfor (int j = 0; j \u0026lt; depthWidth; j++) \t{ \tif (depthBuffer[i * depthWidth + j] == 0) \t{ \tcloudPoints[(i * depthWidth + j) * 3 + 0] = 0; \tcloudPoints[(i * depthWidth + j) * 3 + 1] = 0; \tcloudPoints[(i * depthWidth + j) * 3 + 2] = 0; \tcontinue; \t} \tfloat cx, cy, cz; \tif (cameraMap-\u0026gt;convertDepthToXYZ(j, i, depthBuffer[i*depthWidth+j], cx, cy, cz))  {  cloudPoints[(i * depthWidth + j) * 3 + 0] = -cx;  cloudPoints[(i * depthWidth + j) * 3 + 1] = cy;  cloudPoints[(i * depthWidth + j) * 3 + 2] = cz;  } \t} } int id = 0; for (int i = 0; i \u0026lt; dephtHeight * depthWidth; i++) {  if (cloudPoints[i * 3 + 0] == 0)  continue;  pcl::PointXYZ p;  p.x = cloudPoints[i * 3 + 0];  p.y = cloudPoints[i * 3 + 1];  p.z = cloudPoints[i * 3 + 2];  cloud-\u0026gt;push_back(p);  centerX += p.x;  centerY += p.y;  centerZ += p.z;  id++; } if (id != 0) {  centerX = centerX / id;  centerY = centerY / id;  centerZ = centerZ / id; } else {  centerX = 0;  centerY = 0;  centerZ = 0; } viewer-\u0026gt;setCameraPosition(0, 0, -2, centerX, centerY, centerZ, 0, 0, 0, 0); viewer-\u0026gt;setBackgroundColor(0, 0, 0, 0); viewer-\u0026gt;removeAllPointClouds(); viewer-\u0026gt;addPointCloud(cloud, \u0026#34;cloud\u0026#34;); ui.body3D-\u0026gt;update(); \n去除地面 去除前后效果：\n代码：\n//------------------------------去除地面------------------------------------ for (int i =0; i \u0026lt; dephtHeight; i++) {  for (int j = 0; j \u0026lt; depthWidth; j++)  {  float cx, cy, cz;  if (j \u0026lt; 99 || j\u0026gt;99 + 318 || !cameraMap-\u0026gt;convertDepthToXYZ(j, i, depthBuffer[i*depthWidth+j], cx, cy, cz) || cy \u0026lt; -cameraHeight)  depthBuffer[i*depthWidth + j] = 0;  } } 代码解读：\n遍历每一个像素点，满足if语句中的任何一个条件就将该点的深度值置为0\n  j\u0026lt;99，高度大概低于脚\n  j\u0026gt;99+318，高度大概高于头\n  !cameraMap-\u0026gt;convertDepthToXYZ(j, i, depthBuffer[i*depthWidth+j], cx, cy, cz)\n前三个参数分别为像素点的列索引、行索引、深度值，分别对应X、Y、Z坐标；cx、cy、cz为函数的返回值\n函数convertDepthToXYZ：\nconst float cx(this-\u0026gt;d_cx), cy(this-\u0026gt;d_cy); const float fx(1 / this-\u0026gt;d_fx), fy(1 / this-\u0026gt;d_fy); float xx = distort_map[(y * 512 + x) * 2 + 0]; float yy = distort_map[(y * 512 + x) * 2 + 1]; if (xx\u0026lt;0 || xx \u0026gt;= 512 || yy\u0026lt;0 || yy \u0026gt;= 424)  return 0; const float depth_val = depth / 1000.0f; //scaling factor, so that value of 1 is one meter. if (isnan(depth_val) || depth_val \u0026lt;= 0.001) {  return 0; } else {  dx = (xx + 0.5 - cx) * fx * depth_val;  dy = -(yy + 0.5 - cy) * fy * depth_val;  dz = depth_val;  return 1; } d_cx，259.464：相机的水平方向中心点\nd_cy，202.937：相机的垂直方向中心点\nd_fx，364.503：相机的水平方向焦距\nd_fy，364.503：相机的垂直方向焦距\n成像时的x、y坐标会产生偏差(失真)，一维数组distort_map中存储的是利用相机的参数计算后的正确坐标（xx,yy）\n真实坐标在图像范围外，则该点无效\nif (xx\u0026lt;0 || xx \u0026gt;= 512 || yy\u0026lt;0 || yy \u0026gt;= 424)  return 0; 原始深度值的单位为毫米，转换为米：\n如果得到空值或者深度小于0.001米，则该点无效\nconst float depth_val = depth / 1000.0f; //scaling factor, so that value of 1 is one meter. if (isnan(depth_val) || depth_val \u0026lt;= 0.001) {  return 0; } \n否则计算（x,y,z）并返回\ndx = (xx + 0.5 - cx) * fx * depth_val; dy = -(yy + 0.5 - cy) * fy * depth_val; dz = depth_val; return 1; !cameraMap-\u0026gt;convertDepthToXYZ()：如果函数的返回值为0，则该点无效\n  cy \u0026lt; -cameraHeight\ncy是负值，cy \u0026lt; -cameraHeight表示该点高于相机高度\n  点云插值  上采样  ​\t当目前拥有的点云数据量较少时，通过内插的方法对点云数据对进行扩充，达到保证基本形状不变的情况下增加点云密度。\n​\thttps://www.bilibili.com/read/cv16262762/\n  Surfaces Generated by Moving Least Squares Methods\nhttps://www.ams.org/journals/mcom/1981-37-155/S0025-5718-1981-0616367-1/S0025-5718-1981-0616367-1.pdf\n  移动最小二乘实现点云插值（上采样 | 增采样）详细讲解\nhttps://blog.csdn.net/weixin_46098577/article/details/119849306\nhttps://blog.csdn.net/baidu_35536188/article/details/123399020\nhttps://blog.csdn.net/dreliveam/article/details/111666235\n  最小二乘\n最小二乘法是解决曲线拟合问题最常用的方法。其基本思路是：令 $$ f(x) = a_1φ_1(x)+a_2φ_2(x)+\u0026hellip;+a_mφ_m(x) $$ 其中$φ_k(x)$是事先选定的一组线性无关的函数，$a_k$是待定系数(k=1,2,\u0026hellip;,m,m\u0026lt;n)，拟合的准则是使$y_i$(i = 1,2,\u0026hellip;,n)与$f(x_i)$的距离$δ_i$的平方和最小，称为最小二乘准则。\n求解目标函数： $$ L(y,f(x,w)) = Σ_1^m[y_i-f(x_i,w_i)]^2 $$ 其中w为函数f的待定参数，求使L取最小值的参数w即可。\n  移动最小二乘\nmls算法本质上和最小二乘一样，是一种拟合数据的算法。区别在于mls是局部的，即通过系数向量和基函数分别对数据中不同位置的节点区域进行拟合，需要计算出全部节点域的拟合函数的参数。而传统的最小二乘是全局的，采用所有的数据进行最小化平方和，不能过滤掉噪声点。\n  使用CloudCompare进行上采样实验\nCloudCompare无法打开.dat文件，用代码将cloud转存成.ply文件\n//将cloud保存为ply文件 string outpath = \u0026#34;cloudBody.ply\u0026#34;; char *path = new char[outpath.size() + 1]; strcpy(path, outpath.c_str()); //写出点云图 pcl::PLYWriter writer; writer.write(path, *cloud, true); 使用CloudCompare的MLS进行上采样：\n原始点云：\n设置MLS参数，上采样后的结果点云：\n  C++实现\n//点云上采样 pcl::PointCloud\u0026lt;pcl::PointXYZ\u0026gt;::Ptr Up_Cloud(new pcl::PointCloud\u0026lt;pcl::PointXYZ\u0026gt;); pcl::MovingLeastSquares\u0026lt;pcl::PointXYZ, pcl::PointXYZ\u0026gt; mls; mls.setInputCloud(cloud); pcl::search::KdTree\u0026lt;pcl::PointXYZ\u0026gt;::Ptr tree(new pcl::search::KdTree\u0026lt;pcl::PointXYZ\u0026gt;()); mls.setSearchMethod(tree); mls.setSearchRadius(0.2); mls.setSqrGaussParam(0.04); mls.setUpsamplingMethod(pcl::MovingLeastSquares\u0026lt;pcl::PointXYZ, pcl::PointXYZ\u0026gt;::SAMPLE_LOCAL_PLANE); mls.setUpsamplingRadius(0.05); mls.setUpsamplingStepSize(0.02); mls.process(*Up_Cloud); 采样前的点云cloud中共有13828个点\n采样后的点云Up_Cloud中共有个221248点\n显示Up_Cloud\npass     点云滤波 点云平滑边缘 "
},
{
	"uri": "http://example.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]