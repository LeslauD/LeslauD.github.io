<!DOCTYPE html>
<html lang="en" class="js csstransforms3d">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Hugo 0.99.1" />
    <meta name="description" content="">


    <link rel="shortcut icon" href="/images/favicon.png" type="image/x-icon" />

    <title>CPP :: 刘顿的博客</title>

    
    <link href="/css/nucleus.css?1659414501" rel="stylesheet">
    <link href="/css/fontawesome-all.min.css?1659414501" rel="stylesheet">
    <link href="/css/hybrid.css?1659414501" rel="stylesheet">
    <link href="/css/featherlight.min.css?1659414501" rel="stylesheet">
    <link href="/css/perfect-scrollbar.min.css?1659414501" rel="stylesheet">
    <link href="/css/auto-complete.css?1659414501" rel="stylesheet">
    <link href="/css/atom-one-dark-reasonable.css?1659414501" rel="stylesheet">
    <link href="/css/theme.css?1659414501" rel="stylesheet">
    <link href="/css/tabs.css?1659414501" rel="stylesheet">
    <link href="/css/hugo-theme.css?1659414501" rel="stylesheet">
    
    <link href="/css/theme-blue.css?1659414501" rel="stylesheet">
    
    

    <script src="/js/jquery-3.3.1.min.js?1659414501"></script>

    <style>
      :root #header + #content > #left > #rlblock_left{
          display:none !important;
      }
      
    </style>
    
  </head>
  <body class="" data-url="/cxx/cpp/">
    <nav id="sidebar" class="">



  <div id="header-wrapper">
    <div id="header">
      <img src="/images/keeprush.png">

    </div>
    
        <div class="searchbox">
    <label for="search-by"><i class="fas fa-search"></i></label>
    <input data-search-input id="search-by" type="search" placeholder="Search...">
    <span data-search-clear=""><i class="fas fa-times"></i></span>
</div>

<script type="text/javascript" src="/js/lunr.min.js?1659414501"></script>
<script type="text/javascript" src="/js/auto-complete.js?1659414501"></script>
<script type="text/javascript">
    
        var baseurl = "http:\/\/example.org\/";
    
</script>
<script type="text/javascript" src="/js/search.js?1659414501"></script>

    
  </div>
  
    <section id="homelinks">
      <ul>
        <li>
            <a class="padding" href='/'><i class='fas fa-home'></i> Home</a>
        </li>
      </ul>
    </section>
  

    <div class="highlightable">
    <ul class="topics">

        
          
          




 
  
    
    <li data-nav-id="/resume/" title="个人简历" class="dd-item
        
        
        
        ">
      <a href="/resume/">
          <b></b>个人简历
          
      </a>
      
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/photograph/" title="摄影" class="dd-item
        
        
        
        ">
      <a href="/photograph/">
          <b></b>摄影
          
      </a>
      
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/algorithm/" title="数据结构与算法" class="dd-item
        
        
        
        ">
      <a href="/algorithm/">
          <b></b>数据结构与算法
          
      </a>
      
      
        <ul>
          
          
            
          
          

        
          
            
            




 
  
    
    <li data-nav-id="/algorithm/leetcode/" title="LeetCode" class="dd-item
        
        
        
        ">
      <a href="/algorithm/leetcode/">
          LeetCode
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/algorithm/newcoder/" title="NewCoder" class="dd-item
        
        
        
        ">
      <a href="/algorithm/newcoder/">
          NewCoder
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/algorithm/pat/" title="PAT" class="dd-item
        
        
        
        ">
      <a href="/algorithm/pat/">
          PAT
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/algorithm/tooffer/" title="剑指Offer" class="dd-item
        
        
        
        ">
      <a href="/algorithm/tooffer/">
          剑指Offer
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/algorithm/datastruct/" title="数据结构" class="dd-item
        
        
        
        ">
      <a href="/algorithm/datastruct/">
          数据结构
          
      </a>
      
      
    </li>
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/machinelearning/" title="机器学习" class="dd-item
        
        
        
        ">
      <a href="/machinelearning/">
          <b></b>机器学习
          
      </a>
      
      
        <ul>
          
          
            
          
          

        
          
            
            




 
  
    
    <li data-nav-id="/machinelearning/recommendedsystem/" title="RecommendedSystem" class="dd-item
        
        
        
        ">
      <a href="/machinelearning/recommendedsystem/">
          RecommendedSystem
          
      </a>
      
      
    </li>
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/deeplearning/" title="深度学习" class="dd-item
        
        
        
        ">
      <a href="/deeplearning/">
          <b></b>深度学习
          
      </a>
      
      
        <ul>
          
          
            
          
          

        
          
            
            




 
  
    
    <li data-nav-id="/deeplearning/tensorflow/" title="TensorFlow" class="dd-item
        
        
        
        ">
      <a href="/deeplearning/tensorflow/">
          TensorFlow
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/deeplearning/basic/" title="基础算法理论" class="dd-item
        
        
        
        ">
      <a href="/deeplearning/basic/">
          基础算法理论
          
      </a>
      
      
    </li>
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/vehicle/" title="车车" class="dd-item
        
        
        
        ">
      <a href="/vehicle/">
          <b></b>车车
          
      </a>
      
      
        <ul>
          
          
            
          
          

        
          
            
            




 
  
    
    <li data-nav-id="/vehicle/santana/" title="1:18 Santana" class="dd-item
        
        
        
        ">
      <a href="/vehicle/santana/">
          1:18 Santana
          
      </a>
      
      
    </li>
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/piano/" title="钢琴" class="dd-item
        
        
        
        ">
      <a href="/piano/">
          <b></b>钢琴
          
      </a>
      
      
        <ul>
          
          
            
          
          

        
          
            
            




 
  
    
    <li data-nav-id="/piano/summer/" title="summer" class="dd-item
        
        
        
        ">
      <a href="/piano/summer/">
          <b></b>summer
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/piano/cannon/" title="卡农" class="dd-item
        
        
        
        ">
      <a href="/piano/cannon/">
          <b></b>卡农
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/piano/basic/" title="基本乐理" class="dd-item
        
        
        
        ">
      <a href="/piano/basic/">
          <b></b>基本乐理
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/piano/sunrise/" title="太阳照常升起" class="dd-item
        
        
        
        ">
      <a href="/piano/sunrise/">
          <b></b>太阳照常升起
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/piano/littlestar/" title="小星星变奏曲" class="dd-item
        
        
        
        ">
      <a href="/piano/littlestar/">
          <b></b>小星星变奏曲
          
      </a>
      
      
    </li>
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/programs/" title="项目" class="dd-item
        
        
        
        ">
      <a href="/programs/">
          <b></b>项目
          
      </a>
      
      
        <ul>
          
          
            
          
          

        
          
            
            




 
  
    
    <li data-nav-id="/programs/bodyassessment/" title="BodyAssessment" class="dd-item
        
        
        
        ">
      <a href="/programs/bodyassessment/">
          <b></b>BodyAssessment
          
      </a>
      
      
        <ul>
          
          
            
          
          

        
          
            
            




 
  
    
    <li data-nav-id="/programs/bodyassessment/imageprocess/" title="ImageProcess" class="dd-item
        
        
        
        ">
      <a href="/programs/bodyassessment/imageprocess/">
          ImageProcess
          
      </a>
      
      
    </li>
  
 

            
          
        
        </ul>
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/programs/joyyourmind/" title="JoyYourMind" class="dd-item
        
        
        
        ">
      <a href="/programs/joyyourmind/">
          <b></b>JoyYourMind
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/programs/millenniumtemple/" title="MillenniumTemple" class="dd-item
        
        
        
        ">
      <a href="/programs/millenniumtemple/">
          <b></b>MillenniumTemple
          
      </a>
      
      
    </li>
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/cxx/" title="CPP" class="dd-item
        parent
        
        
        ">
      <a href="/cxx/">
          <b></b>CPP
          
      </a>
      
      
        <ul>
          
          
            
          
          

        
          
            
            




 
  
    
    <li data-nav-id="/cxx/clang/" title="C language" class="dd-item
        
        
        
        ">
      <a href="/cxx/clang/">
          C language
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/cxx/cpp/" title="CPP" class="dd-item
        parent
        active
        
        ">
      <a href="/cxx/cpp/">
          CPP
          
      </a>
      
      
    </li>
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/bigdata/" title="大数据" class="dd-item
        
        
        
        ">
      <a href="/bigdata/">
          <b></b>大数据
          
      </a>
      
      
        <ul>
          
          
            
          
          

        
          
            
            




 
  
    
    <li data-nav-id="/bigdata/hadoop/" title="Hadoop" class="dd-item
        
        
        
        ">
      <a href="/bigdata/hadoop/">
          Hadoop
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/bigdata/spark/" title="Spark" class="dd-item
        
        
        
        ">
      <a href="/bigdata/spark/">
          Spark
          
      </a>
      
      
    </li>
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
        
    </ul>

    
    

    
    <section id="footer">
      <p>Built with <a href="https://github.com/matcornic/hugo-theme-learn"><i class="fas fa-heart"></i></a> from <a href="https://getgrav.org">Grav</a> and <a href="https://gohugo.io/">Hugo</a></p>

    </section>
  </div>
</nav>




        <section id="body">
        <div id="overlay"></div>
        <div class="padding highlightable">
              
              <div>
                <div id="top-bar">
                
                
                <div id="breadcrumbs" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
                    <span id="sidebar-toggle-span">
                        <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
                          <i class="fas fa-bars"></i>
                        </a>
                    </span>
                  
                  <span id="toc-menu"><i class="fas fa-list-alt"></i></span>
                  
                  <span class="links">
                 
                 
                    
          
          
            
            
          
          
            
            
          
          
            <a href='/'></a> > <a href='/cxx/'>CPP</a> > CPP
          
        
          
        
          
        
                 
                  </span>
                </div>
                
                    <div class="progress">
    <div class="wrapper">
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#c基础">C++基础</a></li>
        <li><a href="#类和对象">类和对象</a></li>
        <li><a href="#模板">模板</a></li>
        <li><a href="#异常">异常</a></li>
        <li><a href="#编程技巧">编程技巧</a></li>
        <li><a href="#继承和多态">继承和多态</a></li>
        <li><a href="#动态内存管理">动态内存管理</a></li>
        <li><a href="#stl">STL</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
</div>

                
              </div>
            </div>
            
        <div id="head-tags">
        
        </div>
        
        <div id="body-inner">
          
            <h1>
              
              CPP
            </h1>
          

        



	<h3 id="c基础">C++基础</h3>
<h4 id="c语言">C语言</h4>
<p><a href="/cxx/clang">^-^</a></p>
<h4 id="函数">函数</h4>
<ul>
<li>函数的默认参数    在函数声明或定义的形参列表中，为形参提供默认值</li>
<li>函数重载
<ul>
<li>同一个作用域内，函数的形参不同，函数名相同，则这些函数构成重载函数(与返回值类型无关)</li>
<li>函数如何构成重载：编译器在编译时对函数进行了重命名</li>
</ul>
</li>
<li>内联函数
<ul>
<li>定义在类内的函数会自动成为内联函数</li>
<li>内联函数只是对编译器的一种建议，编译器可以选择忽略这种建议</li>
<li>内联函数相比普通函数没有函数压栈的开销，提升了程序运行效率</li>
<li>内联是一种以空间换取时间的做法，省去了调用函数的开销，代码很长的函数不适合作为内联函数</li>
</ul>
</li>
</ul>
<h4 id="引用">引用</h4>
<ul>
<li>引用变量是所引用变量的别名，地址与原变量的地址相同</li>
<li>引用与指针
<ul>
<li>引用必须在定义时就要初始化</li>
<li>引用变量和指针变量的自增自减运算</li>
<li>引用和指针变量的大小</li>
</ul>
</li>
<li>引用作为函数参数：参数传递时不会产生临时变量</li>
</ul>
<br>
<h3 id="类和对象">类和对象</h3>
<h4 id="类的默认成员函数">类的默认成员函数</h4>
<ul>
<li>构造函数
<ul>
<li>调用场景：类的对象在被创建时自动调用构造函数</li>
<li>构造函数一般完成构造对象以及初始化工作</li>
<li>如果没有显式定义，编译器会自动产生一个缺省的默认构造函数</li>
<li>无参的构造函数和全缺省值的构造函数都被认为是缺省构造函数，一个类中，缺省的构造函数只能有一个</li>
<li>构造函数没有返回值，可以重载，函数名与类名相同</li>
<li>构造函数的参数列表：
<ul>
<li>更高效(两次构造函数变成一次拷贝构造函数)</li>
<li>const、引用、没有默认参数的构造函数的类对象必须在构造函数的初始化列表中进行初始化</li>
</ul>
</li>
</ul>
</li>
<li>析构函数
<ul>
<li>调用场景：类对象的生命周期结束会自动调用析构函数</li>
<li>析构函数主要完成的是内存的释放以及对象的销毁等工作</li>
<li>析构函数的函数名是在类名前面加上~</li>
<li>如果没有显式的提供析构函数，编译器会自动生成一个默认的析构函数</li>
</ul>
</li>
<li>拷贝构造函数
<ul>
<li>调用场景：用一个已经存在的对象创建一个新对象</li>
<li>拷贝构造函数其实是构造函数的重载</li>
<li>拷贝构造函数的参数必须是引用传参，其他传参方式会引起无穷递归</li>
<li>如果没有显式提供拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数，在默认的拷贝构造函数中采用了浅拷贝的方式</li>
</ul>
</li>
<li>赋值运算符重载</li>
<li>取地址运算符重载</li>
<li>const修饰的取地址运算符重载</li>
</ul>
<h4 id="this指针">this指针</h4>
<ul>
<li>指向类的对象的地址</li>
<li>构造函数和静态成员函数中不存在this指针</li>
<li>this隐式地存在在类的成员函数中，但可以进行显式访问</li>
</ul>
<h4 id="静态成员">静态成员</h4>
<ul>
<li>静态成员属于类，不属于对象</li>
<li>静态成员变量和函数需要在类外进行定义和初始化</li>
</ul>
<h4 id="友元">友元</h4>
<ul>
<li>友元类
<ul>
<li>一个类被friend class在另一个类中，这另一个类可以访问这个类的对象的成员</li>
</ul>
</li>
<li>友元函数
<ul>
<li>友元函数可以访问类的成员</li>
</ul>
</li>
</ul>
<h4 id="const成员函数">const成员函数</h4>
<ul>
<li>this指针指向的内容不能被修改</li>
</ul>
<br>
<h3 id="模板">模板</h3>
<h4 id="函数模板">函数模板</h4>
<ul>
<li>template&lt;模板参数&gt;</li>
<li>实例化函数模板       通过函数实参推演模板实参，并绑定到模板参数上</li>
</ul>
<h4 id="非类型模板参数">非类型模板参数</h4>
<h4 id="类模板">类模板</h4>
<ul>
<li>使用了类模板后，用类模板创建一个对象时必须显式地提供类型</li>
<li>当类中的成员函数在类外定义时，必须加上template后接模板参数列表</li>
<li>返回值，类名作为形参  需要加上模板参数列表</li>
</ul>
<h4 id="分离编译">分离编译</h4>
<ul>
<li>类的定义和类中函数的定义放在一个文件中</li>
</ul>
<h4 id="模板的特化">模板的特化</h4>
<ul>
<li>重新定义模板时在模板参数列表中显式地指定类型</li>
</ul>
<br>
<h3 id="异常">异常</h3>
<h4 id="异常对象">异常对象</h4>
<ul>
<li>编译器使用throw抛出去的表达式</li>
</ul>
<h4 id="异常产生-throw">异常产生 throw</h4>
<h4 id="异常处理-try与catch">异常处理 try与catch</h4>
<ul>
<li>一个异常如果没有被捕获，则会提前终止程序</li>
<li>栈展开的过程中对象被自动销毁(例如在构造函数中抛出异常)</li>
<li>如果析构函数中要抛出异常      try语句和catch语句应写在析构函数内部</li>
</ul>
<br>
<h3 id="编程技巧">编程技巧</h3>
<h4 id="浅拷贝深拷贝写时拷贝">浅拷贝/深拷贝/写时拷贝</h4>
<h4 id="类型萃取">类型萃取</h4>
<h4 id="泛型编程">泛型编程</h4>
<br>
<h3 id="继承和多态">继承和多态</h3>
<h4 id="继承">继承</h4>
<ul>
<li>继承是面向对象的重要复用手段</li>
<li>三种继承关系
<ul>
<li>公有继承：public
<ul>
<li>基类的非私有成员在子类访问属性不变</li>
<li>is-a原则</li>
</ul>
</li>
<li>私有继承：private
<ul>
<li>基类的非私有成员都变为子类的私有成员</li>
</ul>
</li>
<li>保护继承：protected
<ul>
<li>基类的非私有成员都变为子类的protected成员</li>
</ul>
</li>
</ul>
</li>
<li>注：基类的私有成员在派生类中不能访问</li>
<li>赋值兼容规则
<ul>
<li>可以用一个子类对象给一个父类对象赋值</li>
<li>父类对象的指针或引用可以指向子类对象</li>
<li>上面两条反转过来不能实现，虽然可以进行强制类型转换，但这样非常容易出现访问错误的情况</li>
</ul>
</li>
<li>派生类的6个默认构造函数</li>
<li>菱形继承
<ul>
<li>在孙子类的对象中存在两份父类的成员(二义性、数据冗余)       解决方法：虚拟继承</li>
<li>虚拟继承
<ul>
<li>专门用来解决菱形继承中存在的二义性和数据冗余的问题</li>
<li>使用虚拟继承会带来性能上的损耗</li>
<li>采用的偏移量的方式来解决二义性的问题</li>
</ul>
</li>
</ul>
</li>
<li>纯虚函数
<ul>
<li>在函数形参列表后写上“=0”叫做纯虚函数</li>
<li>包含纯虚函数的类叫做抽象类，抽象类不能实例化，只有在派生类中重新定义后才能实例化出对象</li>
</ul>
</li>
<li>把析构函数写成虚函数      不会造成内存泄漏(编译器在这一块做了特殊处理)</li>
</ul>
<h4 id="多态">多态</h4>
<ul>
<li>什么是多态
<ul>
<li>一个接口，多种方法</li>
</ul>
</li>
<li>多态的实现条件
<ul>
<li>继承关系</li>
<li>只有在父类定义了虚函数，并且子类重写虚函数的情况下多态才能被实现</li>
<li>必须是父类的指针/引用指向子类或者父类的对象</li>
</ul>
</li>
<li>多态的实现原因&mdash;虚函数列表
<ul>
<li>虚函数列表是用一块连续的内存来存储虚函数的地址</li>
<li>虚函数表怎么解决虚函数的重写问题
<ul>
<li>父类中的虚函数如果在子类中被重新定义，则构成重写，虚函数表中的父类函数的弟子被子类函数所覆盖</li>
<li>子类重写父类的虚函数形参和函数名以及返回类型必须相同</li>
<li>上述规则对一条无效：斜变(函数返回值类型为类本身的指针或引用时函数重写仍然发生)：父类与子类必须对应</li>
<li>final关键字      定义在函数的形参列表后面，不允许派生类的子类的虚构函数进行重写</li>
<li>override关键字      会匹配子类与父类函数名相同的函数形参和类型是否一致，不一致则会报错</li>
</ul>
</li>
<li>单继承      只会出现一张虚函数表，虚函数表先存放父类的虚函数，再存放子类的虚函数</li>
<li>多继承      会出现多个虚函数表，子类的虚函数会放在第一个虚函数表中</li>
</ul>
</li>
<li>静态多态      函数重载      静态多态主要再编译期间发生，例如函数重载在编译期间对函数名进行了重命名</li>
</ul>
<br>
<h3 id="动态内存管理">动态内存管理</h3>
<h4 id="new和delete">new和delete</h4>
<ul>
<li>new开辟空间可以进行初始化      eg: new int(10)</li>
</ul>
<h4 id="new和delete-1">new[]和delete[]</h4>
<ul>
<li>new int[10]()也可以进行初始化，但只能是上面这种形式，开辟的数组被初始化为0</li>
</ul>
<h4 id="相比于c语言的动态内存管理c的动态内存管理">相比于C语言的动态内存管理，C++的动态内存管理</h4>
<ul>
<li>new new[] delete delete[]是操作符，不是函数</li>
<li>new和new[]在开辟空间后还调用了类的构造函数</li>
<li>delete和delete[]先调用析构函数，再释放内存空间</li>
<li>new和new[]不需要进行强制类型转换</li>
</ul>
<h4 id="定位new表达式">定位new表达式</h4>
<ul>
<li>定位new表达式是在已分配的内存空间中调用构造函数初始化一个对象</li>
<li>new(pA)type(init-list):其中pA是指向初始化这个类并且开辟了内存空间的指针</li>
</ul>
<br>
<br>
<h3 id="stl">STL</h3>
<h4 id="stl六大组件">STL六大组件</h4>
<ul>
<li>
<p>容器(Containers)</p>
<p>容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 vector、map、set 等。容器又分为两种：</p>
<ul>
<li>序列式容器：强调值得排序</li>
<li>关联式容器：二叉树结构，各个元素之间没有严格的物理上的顺序关系</li>
</ul>
</li>
<li>
<p>算法(Algorithm)</p>
<p>算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。sort、find、copy、for_each</p>
</li>
<li>
<p>迭代器(iterators)</p>
<p>迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</p>
</li>
<li>
<p>仿函数</p>
</li>
<li>
<p>适配器</p>
</li>
<li>
<p>空间配置器</p>
</li>
</ul>
<h4 id="vector">vector</h4>
<ul>
<li>
<p>创建：</p>
<ul>
<li>
<p>创建空的vector</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span><span style="color:#f92672">&gt;</span> values;
</span></span></code></pre></div><p>reserve函数增加容量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>values.reserve(<span style="color:#ae81ff">20</span>)
</span></span></code></pre></div></li>
<li>
<p>创建的同时指定初始值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> primes {<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">19</span>};
</span></span></code></pre></div></li>
<li>
<p>创建时指定元素个数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> values(<span style="color:#ae81ff">20</span>);
</span></span></code></pre></div><p>默认初值为0，也可以指定初值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> values(<span style="color:#ae81ff">20</span>,<span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//圆括号中的参数也可以是变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> num<span style="color:#f92672">=</span><span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> value <span style="color:#f92672">=</span><span style="color:#ae81ff">1.0</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> values(num, value);
</span></span></code></pre></div></li>
<li>
<p>通过存储元素类型相同的其他容器创建新的容器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>value1(<span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#39;c&#39;</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>value2(value1);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//也可以指定取其他容器中的哪些元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> array[]<span style="color:#f92672">=</span>{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>values(array, array<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>);<span style="color:#75715e">//values 将保存{1,2}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>value1{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>value2(std<span style="color:#f92672">::</span>begin(value1),std<span style="color:#f92672">::</span>begin(value1)<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>);<span style="color:#75715e">//value2保存{1,2,3}
</span></span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>vector的成员函数</p>
<table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
</tr>
<tr>
<td>capacity()</td>
<td>返回当前容量。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>reserve()</td>
<td>增加容器的容量。</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小。</td>
</tr>
<tr>
<td>operator[ ]</td>
<td>重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检查的索引访问元素。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
</tr>
<tr>
<td>data()</td>
<td>返回指向容器中第一个元素的指针。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移出序列尾部的元素。</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>移出一个元素或一段元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在序列尾部生成一个元素。</td>
</tr>
</tbody>
</table>
</li>
</ul>
<br>
<h4 id="pair">pair</h4>
<p>专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素<code>&lt;first, second&gt;</code></p>
<p>pair 类模板定义在<utility>头文件中</p>
<ul>
<li>构造函数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#1) 默认构造函数，即创建空的 pair 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pair();
</span></span><span style="display:flex;"><span><span style="color:#75715e">#2) 直接使用 2 个元素初始化成 pair 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pair (<span style="color:#66d9ef">const</span> first_type<span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">const</span> second_type<span style="color:#f92672">&amp;</span> b);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">V</span><span style="color:#f92672">&gt;</span> pair (<span style="color:#66d9ef">const</span> pair<span style="color:#f92672">&lt;</span>U,V<span style="color:#f92672">&gt;&amp;</span> pr);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#4) 移动构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">V</span><span style="color:#f92672">&gt;</span> pair (pair<span style="color:#f92672">&lt;</span>U,V<span style="color:#f92672">&gt;&amp;&amp;</span> pr);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#5) 使用右值引用参数，创建 pair 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">V</span><span style="color:#f92672">&gt;</span> pair (U<span style="color:#f92672">&amp;&amp;</span> a, V<span style="color:#f92672">&amp;&amp;</span> b);
</span></span></code></pre></div><p><code>&lt;utility&gt;</code>头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 &lt;、&lt;=、&gt;、&gt;=、==、!= 这 6 的运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 <strong>pair.first</strong> 元素的大小，如果相等则继续比较 <strong>pair.second</strong> 元素的大小。</p>
<br>
<h4 id="map">map</h4>
<p>map容器存储的都是pair对象</p>
<ul>
<li>创建</li>
</ul>
<ol>
<li>通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器，比如：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> myMap;
</span></span></code></pre></div><ol start="2">
<li>
<p>创建的同时初始化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> myMap{ {<span style="color:#e6db74">&#34;C语言教程&#34;</span>,<span style="color:#ae81ff">10</span>},{<span style="color:#e6db74">&#34;STL教程&#34;</span>,<span style="color:#ae81ff">20</span>} };
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 或者创建pair对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> myMap{std<span style="color:#f92672">::</span>make_pair(<span style="color:#e6db74">&#34;C语言教程&#34;</span>,<span style="color:#ae81ff">10</span>),std<span style="color:#f92672">::</span>make_pair(<span style="color:#e6db74">&#34;STL教程&#34;</span>,<span style="color:#ae81ff">20</span>)};
</span></span></code></pre></div></li>
<li>
<p>拷贝构造</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> newMap(myMap);
</span></span></code></pre></div></li>
<li>
<p>map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> myMap{ {<span style="color:#e6db74">&#34;C语言教程&#34;</span>,<span style="color:#ae81ff">10</span>},{<span style="color:#e6db74">&#34;STL教程&#34;</span>,<span style="color:#ae81ff">20</span>} };
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> newMap(<span style="color:#f92672">++</span>myMap.begin(), myMap.end());
</span></span></code></pre></div></li>
<li>
<p>手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less<T> 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>myMap{ {<span style="color:#e6db74">&#34;C语言教程&#34;</span>,<span style="color:#ae81ff">10</span>},{<span style="color:#e6db74">&#34;STL教程&#34;</span>,<span style="color:#ae81ff">20</span>} };
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, <span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>less<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span>myMap{ {<span style="color:#e6db74">&#34;C语言教程&#34;</span>,<span style="color:#ae81ff">10</span>},{<span style="color:#e6db74">&#34;STL教程&#34;</span>,<span style="color:#ae81ff">20</span>} };
</span></span></code></pre></div><p>&lt;&ldquo;C语言教程&rdquo;, 10&gt;
&lt;&ldquo;STL教程&rdquo;, 20&gt;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, <span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>greater<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span>myMap{ {<span style="color:#e6db74">&#34;C语言教程&#34;</span>,<span style="color:#ae81ff">10</span>},{<span style="color:#e6db74">&#34;STL教程&#34;</span>,<span style="color:#ae81ff">20</span>} };
</span></span></code></pre></div><p>&lt;&ldquo;STL教程&rdquo;, 20&gt;
&lt;&ldquo;C语言教程&rdquo;, 10&gt;</p>
</li>
</ol>
<ul>
<li>map容器包含的成员方法</li>
</ul>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 map 容器中存有键值对的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>operator[]</td>
<td>map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。</td>
</tr>
<tr>
<td>at(key)</td>
<td>找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 map 容器中插入键值对。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody>
</table>
<br>
<h4 id="set">set</h4>
<p>set 容器存储的各个元素的值必须各不相同,采用默认的 std::less&lt;T&gt; 规则排序</p>
<ul>
<li>
<p>创建</p>
<ol>
<li>
<p>调用默认构造函数，创建空的 set 容器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> myset;
</span></span></code></pre></div></li>
<li>
<p>创建的同时初始化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> myset{<span style="color:#e6db74">&#34;http://c.biancheng.net/java/&#34;</span>,
</span></span><span style="display:flex;"><span>                            <span style="color:#e6db74">&#34;http://c.biancheng.net/stl/&#34;</span>,
</span></span><span style="display:flex;"><span>                            <span style="color:#e6db74">&#34;http://c.biancheng.net/python/&#34;</span>};
</span></span></code></pre></div></li>
<li>
<p>拷贝构造函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> copyset(myset);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//等同于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> copyset <span style="color:#f92672">=</span> myset
</span></span></code></pre></div></li>
<li>
<p>取已有 set 容器中的部分元素，来初始化新 set 容器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> myset{ <span style="color:#e6db74">&#34;http://c.biancheng.net/java/&#34;</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;http://c.biancheng.net/stl/&#34;</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;http://c.biancheng.net/python/&#34;</span> };
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> copyset(<span style="color:#f92672">++</span>myset.begin(), myset.end());
</span></span></code></pre></div></li>
<li>
<p>手动修改 set 容器中的排序规则</p>
<pre tabindex="0"><code class="language-c+" data-lang="c+">std::set&lt;std::string,std::greater&lt;string&gt; &gt; myset{
    &#34;http://c.biancheng.net/java/&#34;,
    &#34;http://c.biancheng.net/stl/&#34;,
    &#34;http://c.biancheng.net/python/&#34;};
</code></pre></li>
</ol>
</li>
<li>
<p>成员方法</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>find(val)</td>
<td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(val)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 set 容器中存有元素的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 set 容器中插入元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 set 容器中存储的元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(val)</td>
<td>在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody>
</table>
</li>
</ul>
<br>
<h4 id="unorder_map">unorder_map</h4>
<p>unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。</p>
<br>
<br>
<br>
<h4 id="stack">stack</h4>
<p>#include &lt;stack&gt;</p>
<ul>
<li>
<p>创建</p>
<pre tabindex="0"><code>std::stack&lt;int&gt; values;
</code></pre></li>
<li>
<p>成员函数</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>empty()</td>
<td>当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回 stack 栈中存储元素的个数。</td>
</tr>
<tr>
<td>top()</td>
<td>返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，程序会报错。</td>
</tr>
<tr>
<td>push(const T&amp; val)</td>
<td>先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</td>
</tr>
<tr>
<td>push(T&amp;&amp; obj)</td>
<td>以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</td>
</tr>
<tr>
<td>pop()</td>
<td>弹出栈顶元素。</td>
</tr>
<tr>
<td>emplace(arg&hellip;)</td>
<td>arg&hellip; 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素。</td>
</tr>
<tr>
<td>swap(stack<T> &amp; other_stack)</td>
<td>将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="queue">queue</h4>
<p>#include &lt;queue&gt;</p>
<ul>
<li>
<p>创建</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> values;
</span></span></code></pre></div></li>
<li>
<p>成员方法</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>empty()</td>
<td>如果 queue 中没有元素的话，返回 true。</td>
</tr>
<tr>
<td>size()</td>
<td>返回 queue 中元素的个数。</td>
</tr>
<tr>
<td>front()</td>
<td>返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</td>
</tr>
<tr>
<td>back()</td>
<td>返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</td>
</tr>
<tr>
<td>push(const T&amp; obj)</td>
<td>在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在 queue 的尾部直接添加一个元素。</td>
</tr>
<tr>
<td>push(T&amp;&amp; obj)</td>
<td>以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。</td>
</tr>
<tr>
<td>pop()</td>
<td>删除 queue 中的第一个元素。</td>
</tr>
<tr>
<td>swap(queue<T> &amp;other_queue)</td>
<td>将两个 queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="c常用算法">C++常用算法</h4>
<h5 id="sort">sort()</h5>





<footer class=" footline" >
	
</footer>

<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>